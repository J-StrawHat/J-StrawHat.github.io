<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「JavaSE学习笔记07」IO流 | JoyDee's Blog</title><meta name="keywords" content="JavaSE"><meta name="author" content="Joy Dee"><meta name="copyright" content="Joy Dee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶Chapter 13. IO流 ¶13.1 File类 java.io.File类是文件（file）和目录（文件夹）（directory）路径名（path）的抽象表示，主要用于文件和目录的创建、查找和删除等操作。  一个File对象，代表硬盘中实际存在的一个文件或者目录（文件夹）。   绝对路径：从盘符开始的路径，是完整的路径。eg: D:\\aaa\\233.txt 相对路径：相对于项目目录的"><meta property="og:type" content="article"><meta property="og:title" content="「JavaSE学习笔记07」IO流"><meta property="og:url" content="https://www.joydee.top/posts/42f17ec5/index.html"><meta property="og:site_name" content="JoyDee&#39;s Blog"><meta property="og:description" content="¶Chapter 13. IO流 ¶13.1 File类 java.io.File类是文件（file）和目录（文件夹）（directory）路径名（path）的抽象表示，主要用于文件和目录的创建、查找和删除等操作。  一个File对象，代表硬盘中实际存在的一个文件或者目录（文件夹）。   绝对路径：从盘符开始的路径，是完整的路径。eg: D:\\aaa\\233.txt 相对路径：相对于项目目录的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif"><meta property="article:published_time" content="2020-11-12T08:35:00.000Z"><meta property="article:modified_time" content="2021-09-07T07:17:26.199Z"><meta property="article:author" content="Joy Dee"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.joydee.top/posts/42f17ec5/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><meta name="google-site-verification" content="FcqPwEYbr_cknqo4XYD1DIbaczUgJwPf9WVNALOG_rA"><meta name="baidu-site-verification" content="code-BTKhd4k3xT"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3c4988fb9892b3bebf918781af0b8ace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-184747878-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-184747878-1")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:700},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Joy Dee",link:"链接: ",source:"来源: JoyDee's Blog",info:"本文为作者的原创文章。遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#0483fa",bgDark:"#00c4b6",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"「JavaSE学习笔记07」IO流",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-09-07 15:17:26"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};n(),document.addEventListener("pjax:complete",n)})(window)</script><link rel="stylesheet" href="/css/joydee.css"><link rel="stylesheet" href="/css/night-owl.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@latest/pace-theme-default.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JoyDee's Blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/avatar.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-layer-group"></i> <span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-shapes"></i> <span>文章分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i> <span>时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tag"></i> <span>标签云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-user-graduate"></i> <span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://music.apple.com/cn/browse"><i class="fa-fw fas fa-music"></i> <span>AppleMusic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://portal.qiniu.com/home"><i class="fa-fw fas fa-images"></i> <span>七牛云图床</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i> <span>关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JoyDee's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-layer-group"></i> <span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-shapes"></i> <span>文章分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i> <span>时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tag"></i> <span>标签云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-user-graduate"></i> <span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://music.apple.com/cn/browse"><i class="fa-fw fas fa-music"></i> <span>AppleMusic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://portal.qiniu.com/home"><i class="fa-fw fas fa-images"></i> <span>七牛云图床</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i> <span>关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="coverdiv"><img id="post-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"></div><div id="post-info"><div id="post-categories-container"><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/JavaSE/">JavaSE</a></span></div><h1 class="post-title">「JavaSE学习笔记07」IO流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-12T08:35:00.000Z" title="发表于 2020-11-12 16:35:00">2020-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-07T07:17:26.199Z" title="更新于 2021-09-07 15:17:26">2021-09-07</time></span><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="fas fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span></span><span class="post-meta-separator">|</span><span data-flag-title="「JavaSE学习笔记07」IO流"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="fas fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/42f17ec5/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-13-IO流"><a class="header-anchor" href="#Chapter-13-IO流">¶</a>Chapter 13. IO流</h1><h2 id="13-1-File类"><a class="header-anchor" href="#13-1-File类">¶</a>13.1 File类</h2><p><code>java.io.File</code>类是文件（<em>file</em>）和目录（文件夹）（<em>directory</em>）路径名（<em>path</em>）的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><blockquote><p>一个<code>File</code>对象，代表硬盘中实际存在的一个文件或者目录（文件夹）。</p></blockquote><ul><li>绝对路径：从盘符开始的路径，是完整的路径。eg: <code>D:\\aaa\\233.txt</code></li><li>相对路径：相对于项目目录的路径，是便携的路径（开发常用）。eg: <code>233.txt</code></li></ul><h3 id="13-1-1-构造方法"><a class="header-anchor" href="#13-1-1-构造方法">¶</a>13.1.1 构造方法</h3><p>无论该路径下是否存在文件或者目录，都不影响<code>File</code>对象的创建。</p><ul><li><p><code>public File(String pathname)</code>：通过将给定的<strong>路径名字符串</strong><code>pathname</code>转换为抽象路径名，以创建新的<code>File</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String pathname = <span class="hljs-string">&quot;D:\\aaa\\233.txt&quot;</span>;<br>File myfile = <span class="hljs-keyword">new</span> File(pathname); <br></code></pre></td></tr></table></figure></li><li><p><code>public File(String parent, String child)</code>：从<strong>父路径名字字符串和子路径名字符串</strong>，创建新的<code>File</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String parent = <span class="hljs-string">&quot;D:\\aaa&quot;</span>;<br>String name = <span class="hljs-string">&quot;233.txt&quot;</span>;<br>File myfile = <span class="hljs-keyword">new</span> File(parent, child);<br></code></pre></td></tr></table></figure></li><li><p><code>public File(File parent, String child)</code>：从<strong>父抽象路径名和子路径名字符串</strong>，创建新的<code>File</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">File parentDir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;D:\\aaa&quot;</span>);<br>String child = <span class="hljs-string">&quot;233.txt&quot;</span>;<br>File myfile = <span class="hljs-keyword">new</span> File(parentDir, child);<br></code></pre></td></tr></table></figure></li></ul><h3 id="13-1-2-关于获取信息的方法"><a class="header-anchor" href="#13-1-2-关于获取信息的方法">¶</a>13.1.2 关于获取信息的方法</h3><ul><li><p><code>public String getAbsolutePath()</code>：返回此<code>File</code>的<strong>绝对</strong>路径名的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:\\素材\\灵感\\GVLOGO2333332.png&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;文件的绝对路径为：&quot;</span> + f.getAbsolutePath());<br><span class="hljs-comment">//输出结果为：文件的绝对路径为：E:\素材\灵感\GVLOGO2333332.png</span><br><br>File f_2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;灵感\\GVLOGO2333332.png&quot;</span>); <span class="hljs-comment">//传入相对路径</span><br>System.out.println(<span class="hljs-string">&quot;文件的绝对路径为：&quot;</span> + f_2.getAbsolutePath()); <span class="hljs-comment">//自动找到绝对路径，但不一定与实际相符。</span><br><span class="hljs-comment">//输出结果为：E:\IDEA-Projects\basic-codes\灵感\GVLOGO2333332.png</span><br></code></pre></td></tr></table></figure></li><li><p><code>public String getPath()</code>：将此<code>File</code>转换为路径名的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:\\素材\\灵感\\GVLOGO2333332.png&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;文件的构造路径为：&quot;</span> + f.getPath());\<br><span class="hljs-comment">//输出结果为：文件的构造路径为：E:\素材\灵感\GVLOGO2333332.png</span><br>    <br>File f_2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;灵感\\GVLOGO2333332.png&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;文件的构造路径为：&quot;</span> + f_2.getPath());<br><span class="hljs-comment">//输出结果为：文件的构造路径为：灵感\GVLOGO2333332.png</span><br></code></pre></td></tr></table></figure></li><li><p><code>public String getName()</code>：返回由此<code>File</code>表示的文件或目录的名称字符串。</p></li><li><p><code>public long length()</code>：返回由此<code>File</code>表示的文件的大小（以字节为单位）。</p></li></ul><h3 id="13-1-3-关于判断的方法"><a class="header-anchor" href="#13-1-3-关于判断的方法">¶</a>13.1.3 关于判断的方法</h3><ul><li><code>public boolean exists()</code>：此<code>File</code>表示的<strong>文件或目录</strong>是否实际存在。</li><li><code>public boolean isDirectory()</code>：此<code>File</code>表示的是否为<strong>目录</strong>。</li><li><code>public boolean isFile()</code>：此<code>File</code>表示的是否为<strong>文件</strong>。</li></ul><h3 id="13-1-4-关于创建或删除的方法"><a class="header-anchor" href="#13-1-4-关于创建或删除的方法">¶</a>13.1.4 关于创建或删除的方法</h3><ul><li><p><code>public boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时，创建一个新的空<strong>文件</strong>。当该文件在实际当中并不存在时，返回<code>true</code>（表示创建文件）；否则，返回<code>false</code>（不会再创建）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;是否存在：&quot;</span> + f.exists()); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;是否创建：&quot;</span> + f.createNewFile()); <span class="hljs-comment">//注意，该方法需要对IO异常进行处理 </span><br>System.out.println(<span class="hljs-string">&quot;是否存在：&quot;</span> + f.exists()); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>注意，此方法只能创建<strong>文件</strong>，不能创建文件夹。且要保证创建文件的路径必须存在，否则抛出异常。</p></li><li><p><code>public boolean mkdir()</code>：创建由此<code>File</code>表示的<strong>单级</strong>空目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDir2333&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;是否存在：&quot;</span> + f.exists());<br>System.out.println(<span class="hljs-string">&quot;是否创建：&quot;</span> + f.mkdir());<br>System.out.println(<span class="hljs-string">&quot;是否存在：&quot;</span> + f.exists());<br></code></pre></td></tr></table></figure><p><code>public boolean mkdirs()</code>：创建由此<code>File</code>表示的目录，包括任何必需但不存在的父目录。也就说，既可创建单级空文件夹，也可创建多级文件夹。</p><p>其中创建文件夹的路径和名称在构造方法中给出（即构造方法的参数）。当文件夹不存在时，方法会创建文件夹并返回<code>true</code>；当文件夹在实际中已经存在，则不会创建并返回<code>false</code>；当构造方法中给出的路径不存在，返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDir666\\newDir668&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;是否创建：&quot;</span> + f.mkdirs()); <span class="hljs-comment">//true</span><br>File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;newDir666\\newDir668&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;是否存在：&quot;</span> + f2.mkdirs()); <span class="hljs-comment">//false, 无需创建</span><br></code></pre></td></tr></table></figure></li><li><p><code>public boolean delete()</code>：删除由此<code>File</code>表示的文件或目录。当文件或目录删除成功则返回<code>true</code>；当文件夹中<strong>有内容</strong>，则不会删除，且返回<code>false</code>；当构造方法中路径在实际中并不存在，返回<code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(f.delete()); <span class="hljs-comment">//true</span><br>System.out.println(f2.delete()); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="13-1-5-目录的遍历"><a class="header-anchor" href="#13-1-5-目录的遍历">¶</a>13.1.5 目录的遍历</h3><ul><li><p><code>public String[] list()</code>：返回一个<code>String</code>数组，表示该<code>File</code><strong>目录中</strong>所有子文件或目录的名称字符串。</p></li><li><p><code>public File[] listFiles()</code>：返回一个<code>File</code>数组，表示该<code>File</code><strong>目录中</strong>所有子文件或目录的<code>File</code>对象（具有更多信息）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File dir = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:\\素材\\灵感&quot;</span>);<br><span class="hljs-comment">//获取当前目录下的文件/文件夹名称</span><br>String[] names = dir.list(); <br><span class="hljs-keyword">for</span>(String name : names) System.out.println(name);<br><span class="hljs-comment">//获取当前目录下的文件/文件夹对象</span><br>File[] files = dir.listFiles(); <br><span class="hljs-keyword">for</span>(File file : files) System.out.println(file);<br></code></pre></td></tr></table></figure><p>注意，调用上面两种方法的<code>File</code>对象，表示的必须是实际存在的目录，否则会抛出空指针异常。</p></li></ul><p>文件搜索的案例：</p><blockquote><p>搜索<code>D:\aaa</code>目录中的<code>.java</code>文件。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        String pathName = <span class="hljs-keyword">new</span> Scanner(System.in).next();<br>        File fir = <span class="hljs-keyword">new</span> File(pathName);<br>        findDir(fir);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findDir</span><span class="hljs-params">(File dir)</span></span>&#123;<br>        File[] files = dir.listFiles();<br>        <span class="hljs-keyword">for</span>(File file : files)&#123;<br>            <span class="hljs-keyword">if</span>(file.isFile())&#123; <span class="hljs-comment">//是文件，到达递归基</span><br>                <span class="hljs-keyword">if</span>(file.getName().toLowerCase().endsWith(<span class="hljs-string">&quot;.java&quot;</span>))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;文件:&quot;</span> + file.getAbsolutePath());<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//是目录，继续深搜</span><br>                findDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-1-6-文件过滤器的优化"><a class="header-anchor" href="#13-1-6-文件过滤器的优化">¶</a>13.1.6 文件过滤器的优化</h3><p><code>java.io.FileFilter</code>，是一个接口，是<code>File</code>的过滤器。该接口的对象，只有一个方法，可以传递给<code>File</code>类的<code>listFiles(FileFilter)</code>作为参数：</p><ul><li><p><code>boolean accept(File pathname)</code></p><p>测试<code>pathname</code>是否应该包含在当前<code>File</code>目录中，保留住则返回<code>true</code>，过滤掉则返回<code>false</code>。其保留规则：要么是<code>.java</code>文件；要么是目录，用于继续遍历。</p><blockquote><p>接口作为参数，则需传递子类对象，并覆写其中方法，我们选择匿名内部类方式较为方便。</p></blockquote><p>通过过滤器作业，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可直接打印。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        String pathName = <span class="hljs-keyword">new</span> Scanner(System.in).next();<br>        File fir = <span class="hljs-keyword">new</span> File(pathName);<br>        findDir(fir);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findDir</span><span class="hljs-params">(File dir)</span></span>&#123;<br>        File[] files = dir.listFiles(<span class="hljs-keyword">new</span> FileFilter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File pathname)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> pathname.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>) || pathname.isDirectory();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span>(File file : files)&#123;<br>            <span class="hljs-keyword">if</span>(file.isFile())&#123; <span class="hljs-comment">//是文件，到达递归基</span><br>                <span class="hljs-keyword">if</span>(file.getName().endsWith(<span class="hljs-string">&quot;.java&quot;</span>))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;文件:&quot;</span> + file.getAbsolutePath());<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//是目录，继续深搜</span><br>                findDir(file);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-2-I-O流概述"><a class="header-anchor" href="#13-2-I-O流概述">¶</a>13.2 I/O流概述</h2><p>Java中I/O操作主要指<code>java.io</code>包下的内容，进行输入、输出操作。</p><h3 id="13-2-1-IO的分类"><a class="header-anchor" href="#13-2-1-IO的分类">¶</a>13.2.1 IO的分类</h3><p>根据数据的流向分为：输入流和输出流。</p><ul><li><strong>输入流</strong>：将数据从其他设备上<strong>读取</strong>到内存中的流。</li><li><strong>输出流</strong>：将数据从内存中<strong>写出</strong>到其他设备上的流。</li></ul><p>根据数据的类型分为：字节流和字符流。</p><ul><li><strong>字节流</strong>：以字节为单位，读写数据的流。</li><li><strong>字符流</strong>：以字符为单位，读写数据的流。</li></ul><table><thead><tr><th></th><th>输入流</th><th>输出流</th></tr></thead><tbody><tr><td><strong>字节流</strong></td><td>字节输入流（<strong>InputStream</strong>）</td><td>字节输出流（<strong>OutputStream</strong>）</td></tr><tr><td><strong>字符流</strong></td><td>字符输入流（<strong>Reader</strong>）</td><td>字符输出流（<strong>Writer</strong>）</td></tr></tbody></table><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/1_io.jpg" width="500"><p>由于简单演示，在介绍字节流、字符流时，我们暂且将IO异常抛出。实际开发中，针对IO异常，应使用<code>try...catch</code>代码块进行处理。</p><h2 id="13-3-字节流"><a class="header-anchor" href="#13-3-字节流">¶</a>13.3 字节流</h2><h3 id="13-3-1-字节输出流（OutputStream）"><a class="header-anchor" href="#13-3-1-字节输出流（OutputStream）">¶</a>13.3.1 字节输出流（OutputStream）</h3><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的几个基本方法：</p><ul><li><code>public void close()</code>：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><code>public void flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节。</li><li><code>public void write(byte[] b)</code>：将<code>b.length</code>个字节从指定的<code>b</code>字节数组写出此输出流。</li><li><code>public void write(byte[] b, int off, int len)</code>：将指定的<code>b</code>字节数组中从偏移量<code>off</code>开始的<code>len</code>个字节写出此输出流。</li><li><code>public abstract void write(int b)</code>：写出一个字节的数据</li></ul><h3 id="13-3-2-FileOutputStream-类"><a class="header-anchor" href="#13-3-2-FileOutputStream-类">¶</a>13.3.2 FileOutputStream 类</h3><p><code>java.io.FileOutputStream</code> 类 是 文件输出流，它作为<code>OutputStream</code>中的一个子类，用于将数据写出到文件。</p><p>一、构造方法</p><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的<code>File</code>对象表示的文件。</li><li><code>public FileOutputStream(String name)</code>：创建文件输出流写入以指定名称<code>name</code>的文件。</li></ul><p>当你创建一个流对象时，必须传入一个文件路径。若该路径下没有这个文件，则会自动创建；若该文件已存在，则会<strong>清空</strong>该文件中数据。举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;233.txt&quot;</span>); <span class="hljs-comment">//使用File对象</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(f);<br>        FileOutputStream fos_2 = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;b.txt&quot;</span>); <span class="hljs-comment">//使用文件名称创建流对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201113210710.png"><p>二、写出字节数据</p><ol><li><p>写出<strong>字节</strong>：调用<code>write(int b)</code>方法，每次可以写出<strong>一个</strong>字节数据。注意，尽管参数为<code>int</code>类型的四个字节，但只会保留一个字节的信息写出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        fos.write(<span class="hljs-number">97</span>); <span class="hljs-comment">//写入第一个字节，转换为字符即为&#x27;a&#x27;</span><br>        fos.write(<span class="hljs-number">98</span>); <span class="hljs-comment">//写入第二个字节，转换为字符即为&#x27;b&#x27;</span><br>        fos.write(<span class="hljs-number">99</span>);<br>        fos.close(); <span class="hljs-comment">//流操作完毕后必须调用close方法以释放系统资源</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 233.txt文件中打印为：abc</span><br></code></pre></td></tr></table></figure></li><li><p>写出<strong>字节数组</strong>：调用<code>write(byte[] b)</code>方法，每次可以写出数组中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;国奖我来了&quot;</span>.getBytes(); <span class="hljs-comment">//字符串转化为字节数组</span><br>        fos.write(b); <span class="hljs-comment">//写出字节数组数据</span><br>        fos.close(); <span class="hljs-comment">//关闭资源</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 233.txt文件中打印为：国奖我来了</span><br></code></pre></td></tr></table></figure></li><li><p>写出<strong>指定长度</strong>的<strong>字节数组</strong>：调用<code>write(byte[] b, int off, int len)</code>，每次写出时从<code>off</code>索引开始，以<code>len</code>个字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;abcdefgh&quot;</span>.getBytes(); <span class="hljs-comment">//字符串转化为字节数组</span><br>        fos.write(b, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//写出字节数组数据</span><br>        fos.close(); <span class="hljs-comment">//关闭资源</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 233.txt文件中打印为：defg</span><br></code></pre></td></tr></table></figure></li></ol><p>三、数据的<strong>追加</strong>续写</p><p>对于第二点中的方法，每次程序运行，<strong>创建输出流对象</strong>时，都会清空目标文件中的数据。为了保留目标文件中的数据，可以使用下面的构造方法（相比于第一点的构造方法，需要多传入一个<code>append</code>参数）：</p><ul><li><code>public FileOutputStream(File file, boolean append)</code></li><li><code>public FileOutputStream(File file, boolean append)</code></li></ul><p>当传入的<code>append</code>参数为<code>true</code>时表示追加数据，<code>false</code>表示<strong>清空</strong>原有的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;233.txt&quot;</span>, <span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;abcde&quot;</span>.getBytes(); <span class="hljs-comment">//字符串转化为字节数组</span><br>        fos.write(b);<br>        fos.close(); <span class="hljs-comment">//关闭资源</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 对于 233.txt 文件</span><br><span class="hljs-comment">操作前：ddd</span><br><span class="hljs-comment">操作后：dddabcde</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>【附】写出换行</p><ul><li>回车符<code>\r</code>：回到一行的开头（return）</li><li>换行符<code>\n</code>：下一行（newline）</li></ul><p>对于系统中的换行：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Windows</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">Win</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">s</span></span></span></span>系统，每行结尾为：<code>\r\n</code>（回车+换行）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Unix</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mord mathnormal">ni</span><span class="mord mathnormal">x</span></span></span></span>系统，每行结尾为：<code>\n</code>（换行）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">Mac</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span></span></span></span>系统，每行结尾为：<code>\r</code>（回车），从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>c</mi><mtext> </mtext><mi>O</mi><mi>S</mi><mtext> </mtext><mi>X</mi></mrow><annotation encoding="application/x-tex">Mac\ OS\ X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:.05764em">OS</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:.07847em">X</span></span></span></span>开始与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Linux</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">in</span><span class="mord mathnormal">ux</span></span></span></span>统一。</li></ul><h3 id="13-3-3-字节输入流（InputStream）"><a class="header-anchor" href="#13-3-3-字节输入流（InputStream）">¶</a>13.3.3 字节输入流（InputStream）</h3><p><code>java.io.InputStream</code> 抽象类 是表示字节输入流所有类的超类，可以读取字节信息至内存中。它定义了字节输入流的几个基本方法：</p><ul><li><code>public void close()</code>：关闭此输入流并释放与此流相关联的任何系统资源。</li><li><code>public abstract int read()</code>：从数据中读入一个字节，并返回该字节，该方法在碰到流的结尾时返回<code>-1</code></li><li><code>public int read(byte[] b)</code>：读入一个字节数组，并返回实际读入的字节数，或者在碰到流的结尾时返回<code>-1</code>。注意，该方法最多读入<code>b.length</code>个字节。</li><li><code>public int read(byte[] b, int off, int len)</code></li></ul><h3 id="13-3-4-FileInputStream-类"><a class="header-anchor" href="#13-3-4-FileInputStream-类">¶</a>13.3.4 FileInputStream 类</h3><p><code>java.io.FileInpurStream</code> 类 是文件输入流，从文件中读入字节。</p><p>一、构造方法</p><ul><li><code>FileInputStream(File file)</code>：通过打开与实际文件的连接来创建一个<code>FileInputStream</code>，该文件由文件系统中的<code>File</code>对象<code>file</code>命名。</li><li><code>FileInputStream(String name)</code>：通过打开与实际文件的连接来创建一个 <code>FileInputStream</code> ，该文件由文件系统中的路径名 <code>name</code> 命名。</li></ul><p>注意，在创建一个流对象时，必须传入一个文件路径，该路径下如果没有该文件，会抛出<code>FileNotFoundException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>        FileInputStream fos = <span class="hljs-keyword">new</span> FileInputStream(file); <span class="hljs-comment">//使用File对象创建流对象</span><br>        FileInputStream fos_2 = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;233.txt&quot;</span>); <span class="hljs-comment">//使用文件名称创建该流对象。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二、读取字节数据</p><ol><li><p>读取<strong>字节</strong>：调用<code>read()</code>方法，每次可读取一个字节数据，并<strong>提升为<code>int</code>类型</strong>，读取到文件末尾时，返回<code>-1</code>。（注意，文件中含有中文时，读入后会变成乱码！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> b; <span class="hljs-comment">//临时变量，保存读入一个字节数据转化为的int数据</span><br>        <span class="hljs-keyword">while</span>( (b = fis.read()) != -<span class="hljs-number">1</span>)<br>            System.out.println((<span class="hljs-keyword">char</span>)b);<br>        fis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<strong>字节数组</strong>读取：调用<code>read(byte[] b)</code>，每次读入<code>b.length</code>个字节数至数组中，并返回读取到的有效字节个数。同样地，当读取到末尾时，返回<code>-1</code>。</p><blockquote><p>使用数组读入，使得每次读入多个字节，从而减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;read.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//定义2个字节长度的字节数组</span><br>        <span class="hljs-keyword">while</span>((len = fis.read(b)) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//每次读取后，将数组的有效字节部分，转换为字符串并打印</span><br>            System.out.println(<span class="hljs-keyword">new</span> String(b, <span class="hljs-number">0</span>, len)); <span class="hljs-comment">//len表示每次读取的有效字节个数！（想想边界条件）</span><br>        &#125;<br>        fis.close();<span class="hljs-comment">//关闭资源</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果为</span><br><span class="hljs-comment">ab</span><br><span class="hljs-comment">cd</span><br><span class="hljs-comment">e</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="13-3-5-字节流应用：图片复制"><a class="header-anchor" href="#13-3-5-字节流应用：图片复制">¶</a>13.3.5 字节流应用：图片复制</h3><p>复制原理：从已有文件中读入字节，将该字节写出到另一个文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\素材\\灵感\\GVLOGO23.png&quot;</span>); <span class="hljs-comment">//字节输入流对象，构造方法绑定要读入的数据域</span><br>        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;test_copy.jpg&quot;</span>); <span class="hljs-comment">//字节输出流对象，绑定要写入的目的地</span><br>        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> cur;<br>        <span class="hljs-keyword">while</span> ((cur = fis.read(b)) != -<span class="hljs-number">1</span>)&#123;<br>            fos.write(b, <span class="hljs-number">0</span>, cur);<br>        &#125;<br>        fos.close(); <span class="hljs-comment">//先关闭输出流</span><br>        fis.close(); <span class="hljs-comment">//后关闭输入流</span><br>    &#125; <span class="hljs-comment">//先开后关，后开先关。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-4-字符流"><a class="header-anchor" href="#13-4-字符流">¶</a>13.4 字符流</h2><p>在存储<strong>文本字符串</strong>时，需要考虑字符编码（<em>character encoding</em>）方式，Java提供字符流类，以字符为单位读写数据，专门用于处理文本文件（如中文字符）。</p><blockquote><p>字符流，只能操作文本文件，不能操作图片、视频等非文本文件。当我们只希望 读或写 文本文件时，使用字符流；其他情况使用字节流。</p></blockquote><h3 id="13-4-1-字符输入类（Reader）"><a class="header-anchor" href="#13-4-1-字符输入类（Reader）">¶</a>13.4.1 字符输入类（Reader）</h3><p><code>java.io.Reader</code> 抽象类是表示用于读取字符流的所有类的超类，可读入字符信息至内存中。它定义了字符输入流的几个基本方法：</p><blockquote><p>与字节输入类<code>InputStream</code>的基本方法一致，只不过传入的是字符数组而不是字节数组</p></blockquote><ul><li><code>public void close()</code>：关闭此流并释放与此流相关联的任何系统资源。</li><li><code>public int read()</code>：从输入流读入一个字符。</li><li><code>public int read(char[] cbuf)</code>：从输入流中读取一些字符，并将他们存储到字符数组<code>cbuf</code>中。</li></ul><h3 id="13-4-2-FileReader-类"><a class="header-anchor" href="#13-4-2-FileReader-类">¶</a>13.4.2 FileReader 类</h3><p><code>java.io.FileReader</code> 类是读取字符<strong>文件</strong>的便利类，构造时使用系统默认的字符编码和默认字节缓冲区。其构造方法的实现就是使用了 <code>FileInputStream</code> （文件字节输入流）来实现</p><blockquote><p><strong>字符编码</strong>：字节与字符的对应规则，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Windows</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">Win</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">s</span></span></span></span>系统的中文编码默认为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>B</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">GBK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05017em">GB</span><span class="mord mathnormal" style="margin-right:.07153em">K</span></span></span></span>编码表（一个汉字占用2个字节，简体中文），而IDEA中为**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>T</mi><mi>F</mi><mo>−</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">UTF-8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="mord mathnormal" style="margin-right:.13889em">TF</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span></span></span></span>**（一个汉字占用3个字节，8位UniCode转换格式）</p><p>字节缓冲区：一个字节数组，用于临时存储字节数据。</p></blockquote><p>一、构造方法：</p><ul><li><p><code>FileReader(File file)</code>：给定要读取的<code>File</code>对象以创建一个新的<code>FileReader</code>。</p></li><li><p><code>FileReader(String fileName)</code>：给定要读取的文件的名称<code>fileName</code>以创建一个新的<code>FileReader</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(file); <span class="hljs-comment">//使用File对象创建流对象</span><br>        FileReader fr_2 = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;666.txt&quot;</span>); <span class="hljs-comment">//使用文件名称创建流对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>二、读取字符数据</p><ol><li><p>读取<strong>字符</strong>：调用<code>read</code>方法，每次可读入<strong>一个字符</strong>的数据，并提升为<code>int</code>类型，读取到文件末尾时返回<code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> b;<br>        <span class="hljs-keyword">while</span>((b = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println((<span class="hljs-keyword">char</span>)b);<br>        &#125;<br>        fr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<strong>字符数组</strong>读入：调用<code>read(char[] cbuf)</code>方法，每次读入<code>cbuf.length</code>个<strong>字符数</strong>至数组中，并返回读取到的有效字符个数。同样地，当读取到末尾时，返回<code>-1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileReader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span>((len = fr.read(cbuf)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(cbuf, <span class="hljs-number">0</span>, len)); <span class="hljs-comment">//要获取有效字符</span><br>        &#125;<br>        fr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="13-4-3-字符输出流（Writer）"><a class="header-anchor" href="#13-4-3-字符输出流（Writer）">¶</a>13.4.3 字符输出流（Writer）</h3><p><code>java.io.Writer</code> 抽象类 是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地，它定义了字符输出流的几个基本方法：</p><ul><li><code>void write(int c)</code>：写入单个字符。</li><li><code>void write(char[] cbuf)</code>：写入字符数组。</li><li><code>abstract void write(char[] cbuf, int off, int len)</code>：写入字符数组的某一部分，以<code>off</code>作为开始索引，<code>len</code>个需写入的字符个数。</li><li><code>void write(String str)</code>：写入字符串。</li><li><code>void write(String str, int off, int len)</code>：写入字符串的某一部分，以<code>off</code>作为开始索引，<code>len</code>个需写入的字符个数。</li><li><code>void flush()</code>：刷新该流的缓冲。</li><li><code>void close()</code>：关闭此输出流但需要先<strong>刷新</strong>它。</li></ul><h3 id="13-4-4-FileWriter-类"><a class="header-anchor" href="#13-4-4-FileWriter-类">¶</a>13.4.4 FileWriter 类</h3><p><code>java.io.FileWriter</code>类是写出字符至文件的便利类，构造时使用默认的字符编码和默认字节缓冲区。</p><p>一、构造方法</p><ul><li><p><code>FileWriter(File file)</code>：给定要读入的<code>File</code>对象，创建一个新的<code>FileWriter</code>。</p></li><li><p><code>FileWriter(String fileName)</code>：给定要读入的文件名称，创建一个新的<code>FileWriter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(file); <span class="hljs-comment">//使用File对象创建流对象</span><br>        FileWriter fw_2 = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;666.txt&quot;</span>); <span class="hljs-comment">//使用文件名称创建流对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>二、写出字符数据</p><ol><li><p>写出字符：调用<code>write(int b)</code>方法，每次可写出一个字符数据（至内存缓冲区，是字符转换为字节的过程）。</p><blockquote><p>关于关闭和<strong>刷新</strong>：关闭一个输出流的同时，也会冲刷用于该输出流的缓冲区：所有被临时置于缓冲区中，以使用更大的包的形式传递的<strong>字符</strong>在关闭输出流时都将被送出。</p></blockquote><p>当数据不足以填充缓冲区，而又需要往客户端传数据，为了解决这个问题，便有了 <code>flush</code> 的概念，将缓冲区的数据“强迫发送”。</p><p>此外，如果既想写出数据，又想继续使用流，也需要<code>flush</code>方法。</p><ul><li><code>flush</code>：刷新缓冲区，但流对象仍可继续使用。</li><li><code>close</code>：先刷新缓冲区，然后通知系统释放资源，此时流对象不可再被使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        fw.write(<span class="hljs-string">&#x27;刷&#x27;</span>);<br>        fw.flush();<br>        fw.write(<span class="hljs-string">&#x27;新&#x27;</span>);<br>        fw.write(<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">//写出换行！</span><br>        fw.flush();<br>        fw.write(<span class="hljs-string">&#x27;关&#x27;</span>);<br>        fw.close();<br>        <span class="hljs-comment">/*输出结果为：</span><br><span class="hljs-comment">        刷新</span><br><span class="hljs-comment">        关</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//fw.write(&#x27;闭&#x27;); //关闭后再写入会抛出异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>写出字符数组：调用<code>write(char[] cbuf)</code>或<code>write(char[] cbuf, int off, int len)</code>，每次可以写出字符数组中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        <span class="hljs-keyword">char</span>[] arr = <span class="hljs-string">&quot;你好打工人&quot;</span>.toCharArray();<br>        fw.write(arr); <span class="hljs-comment">//你好打工人</span><br>        fw.write(arr, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//打工人</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>写出字符串：调用<code>write(String str)</code>或<code>write(String str, int off, int len)</code>，每次可写出字符串中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>        String msg = <span class="hljs-string">&quot;你好打工人&quot;</span>;<br>        fw.write(msg); <span class="hljs-comment">//你好打工人</span><br>        fw.write(msg, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//打工人</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="13-5-IO-异常的处理"><a class="header-anchor" href="#13-5-IO-异常的处理">¶</a>13.5 IO 异常的处理</h2><h3 id="13-5-1-JDK7前的处理"><a class="header-anchor" href="#13-5-1-JDK7前的处理">¶</a>13.5.1 JDK7前的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FileWriter fw = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//注意，应在外面定义这个file对象（别忘了赋初值）</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;233.txt&quot;</span>);<br>            fw.write(<span class="hljs-string">&quot;早安打工人!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">//关闭流资源</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(fw != <span class="hljs-keyword">null</span>) <span class="hljs-comment">//fw有可能为空，为空则不能再调用其方法。</span><br>                    fw.close(); <span class="hljs-comment">//然而，close也有可能抛出异常</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-5-2-JDK7的处理"><a class="header-anchor" href="#13-5-2-JDK7的处理">¶</a>13.5.2 JDK7的处理</h3><p>可以使用JDK7优化后的<code>try-with-resource</code>语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（<em>resource</em>），指在程序完成后必须关闭的对象。</p><p>格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(创建流对象语句)&#123; <span class="hljs-comment">//可以使用多个，若有多个则使用&#x27;;&#x27;隔开</span><br>    <span class="hljs-comment">//读写数据</span><br>&#125; <span class="hljs-keyword">catch</span>(IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>try</code>括号内被引用的对象，能够自动地关闭，无需手动<code>close</code></p><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;233.txt&quot;</span>))&#123;<br>            fw.write(<span class="hljs-string">&quot;早安打工人！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-6-属性集"><a class="header-anchor" href="#13-6-属性集">¶</a>13.6 属性集</h2><p><code>java.util.Properties</code>继承于<code>Hashtable</code>，以表示一个持久的属性集，它使用键-值结果存储数据，每个键及其对应值默认是<strong>字符串</strong>.</p><blockquote><p><code>Properties</code>类 被许多Java类使用，如获取系统属性时，<code>System.getProperties</code>方法即为返回一个<code>Properties</code>对象。</p></blockquote><p>一、构造方法</p><ul><li><code>public Properties()</code>：创建一个空的属性列表。</li></ul><p>二、基本的存储方法</p><ul><li><p><code>public Object setProperty(String key, String value)</code>：保存一对属性。</p></li><li><p><code>public String getProperty(String key)</code>：使用此属性列表中指定的键<code>key</code>搜索属性值。</p></li><li><p><code>public Set&lt;String&gt; stringPropertyNames()</code>：获取由所有键的名称组成的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Properties mypro = <span class="hljs-keyword">new</span> Properties();<br>        <span class="hljs-comment">//添加键值对元素</span><br>        mypro.setProperty(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-string">&quot;233.txt&quot;</span>);<br>        mypro.setProperty(<span class="hljs-string">&quot;length&quot;</span>, <span class="hljs-string">&quot;998244353&quot;</span>);<br>        mypro.setProperty(<span class="hljs-string">&quot;location&quot;</span>, <span class="hljs-string">&quot;D:\\233.txt&quot;</span>);<br>        System.out.println(mypro); <span class="hljs-comment">//打印属性集对象</span><br>        <span class="hljs-comment">//通过键获取属性值</span><br>        System.out.println(mypro.getProperty(<span class="hljs-string">&quot;filename&quot;</span>));<br>        System.out.println(mypro.getProperty(<span class="hljs-string">&quot;length&quot;</span>));<br>        <span class="hljs-comment">//遍历属性值，获取由所有键组成的集合</span><br>        Set&lt;String&gt; mystr = mypro.stringPropertyNames();<br>        <span class="hljs-keyword">for</span>(String key : mystr)&#123;<br>            System.out.println(key + <span class="hljs-string">&quot; : &quot;</span> + mypro.getProperty(key));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>三、与流相关的方法</p><ul><li><p><code>public void load(InputStream inStream)</code>：从字节输入流<code>inStream</code>中读入键值对。通过流对象，可关联至硬盘中保存的某文件中，读取到集合中使用。</p></li><li><p><code>public void load(Reader reader)</code> ：与上同理，传入的是<strong>字符</strong>输入流。</p><p>注意：</p><ol><li>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号(英文)等符号作为分隔符。</li><li>可以使用<code>#</code>进行注释，被注释的键值对不会被读入。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 233.txt文件中 */</span><br>#save data<br>#Sun Nov <span class="hljs-number">15</span> <span class="hljs-number">11</span>:<span class="hljs-number">26</span>:<span class="hljs-number">58</span> CST <span class="hljs-number">2020</span><br>姓名:打工人<br>年龄=<span class="hljs-number">19</span>岁<br>居住地 广州<br>#学校:TSH<br>    <br><span class="hljs-comment">/* JustTest.java文件中 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Properties mypro = <span class="hljs-keyword">new</span> Properties();<br>        mypro.load(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;233.txt&quot;</span>)); <span class="hljs-comment">//字符输入流</span><br>        Set&lt;String&gt; myset = mypro.stringPropertyNames();<br>        <span class="hljs-keyword">for</span>(String key : myset)&#123;<br>            System.out.println(key + <span class="hljs-string">&quot;----&quot;</span> + mypro.getProperty(key));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 输出结果 */</span><br>姓名----打工人<br>居住地----广州<br>年龄----<span class="hljs-number">20</span>岁<br></code></pre></td></tr></table></figure></li></ul><h3 id="BeanUtils-工具类"><a class="header-anchor" href="#BeanUtils-工具类">¶</a>BeanUtils 工具类</h3><p>该工具类，用于简化封装 JavaBean，使用前，需要导入 jar 包（以 <code>commons-beanutils-1.8.0.jar</code> 为例）。</p><p>在 IDEA 中导入类时，注意是选择 apache 的：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210223230303.png" style="zoom:67%"><p>相关方法：</p><ul><li><code>setProperty()</code></li><li><code>getProperty()</code></li><li><code>populate(Object obj, Map map)</code>：将 Map 集合的键值对信息，封装到对应的 JavaBean 对象中。</li></ul><p>代码举例如下：（已提前设计好JavaBean：<code>User</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> top.JoyDee.test;<br><br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanUtils;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> top.JoyDee.domain.User;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanUtilsTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        <span class="hljs-keyword">try</span> &#123;<br>            BeanUtils.setProperty(user, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>            BeanUtils.setProperty(user, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;Zoro&quot;</span>);<br>            System.out.println(user);<br>            <span class="hljs-comment">//输出为：User&#123;id=0, username=&#x27;Zoro&#x27;, password=&#x27;123456&#x27;&#125;</span><br><br>            String password = BeanUtils.getProperty(user, <span class="hljs-string">&quot;password&quot;</span>);<br>            System.out.println(password); <span class="hljs-comment">//输出为：123456</span><br><br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-7-缓冲流"><a class="header-anchor" href="#13-7-缓冲流">¶</a>13.7 缓冲流</h2><p>缓冲流，也叫高效流，是对4个基本的<code>FileXxx</code>流的增强。其基本原理即是，在创建流对象时，创建一个内置的默认大小的缓冲区数组，通过缓冲区的读写，减少系统IO次数，从而提高读写效率。</p><p>按数据类型分类有：</p><ul><li>字节缓冲流：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code></li><li>字符缓冲流：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><h3 id="13-7-1-字节缓冲流"><a class="header-anchor" href="#13-7-1-字节缓冲流">¶</a>13.7.1 字节缓冲流</h3><p>构造方法：</p><ul><li><code>public BufferedInputStream(InputStream in)</code>：创建一个新的缓冲输入流。</li><li><code>public BufferedOutputStream(OutputStream out)</code>：创建一个新的缓冲输出流。</li></ul><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">long</span> st = System.currentTimeMillis();<br>        <span class="hljs-keyword">try</span>( <span class="hljs-comment">//创建流对象</span><br>            BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\素材\\灵感\\GVLOGO233.png&quot;</span>));<br>            BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\素材\\copy.png&quot;</span>));<br>        )&#123;  <span class="hljs-comment">//读写数据</span><br>            <span class="hljs-keyword">int</span> b;<br>            <span class="hljs-keyword">while</span>((b = bis.read()) != -<span class="hljs-number">1</span>)&#123;<br>                bos.write(b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">long</span> ed = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;缓冲流复制时间:&quot;</span> + (ed - st) + <span class="hljs-string">&quot;ms!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出结果:</span><br><span class="hljs-comment">缓冲流复制时间:82ms!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="13-7-2-字符缓冲流"><a class="header-anchor" href="#13-7-2-字符缓冲流">¶</a>13.7.2 字符缓冲流</h3><p>构造方法：</p><ul><li><code>public BufferedReader(Reader in)</code>：创建一个新的缓冲输入流。</li><li><code>public BufferedWriter(Writer out)</code> ：创建一个新的缓冲输出流。</li></ul><p>字符缓冲流的基本方法与普通字符流调用方式一致，但也具备特有的方法：</p><ul><li><p>对于 <code>BufferedReader</code> ，<code>public String readLine()</code>：读一行文字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;E:\\IDEA-Projects\\basic-codes\\233.txt&quot;</span>));<br>        String myline = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//保存读入的一行字符</span><br>        <span class="hljs-keyword">while</span>((myline = br.readLine()) != <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">//读取【每】一行的字符</span><br>            System.out.println(myline); <br>            System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>        &#125;<br>        br.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于 <code>BufferedWriter</code> ，<code>public void newLine()</code>：写出一行 行分隔符，由系统属性定义符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;666.txt&quot;</span>));<br>        bw.write(<span class="hljs-string">&quot;早安&quot;</span>);<br>        bw.newLine(); <span class="hljs-comment">//换行</span><br>        bw.write(<span class="hljs-string">&quot;打工人&quot;</span>);<br>        bw.write(<span class="hljs-string">&quot;好起来了！&quot;</span>);<br>        bw.close();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*输出结果:</span><br><span class="hljs-comment">早安</span><br><span class="hljs-comment">打工人好起来了！</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="13-7-3-缓冲流应用：文本排序"><a class="header-anchor" href="#13-7-3-缓冲流应用：文本排序">¶</a>13.7.3 缓冲流应用：文本排序</h3><p>将下列文本信息按段编号恢复顺序:</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201120215847.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        HashMap&lt;String, String&gt; lineMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(); <span class="hljs-comment">//Map集合，序号作为key，段落文字内容作为value</span><br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;in.txt&quot;</span>));<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;out.txt&quot;</span>));<br>        String myline = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>((myline = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>            String[] twoStrs = myline.split(<span class="hljs-string">&quot;\\.&quot;</span>); <span class="hljs-comment">//将一行文字以.作为分隔符，分隔为两个字符串。</span><br>            <span class="hljs-comment">/* split的工作原理是利用正则表表达式,而在正则表达式中, &quot;.&quot;有特殊意思,所以匹配&quot;.&quot;时要用转义字符&quot;\&quot;,所以在正则表达式中匹配&quot;.&quot;的表达式是&quot;\.&quot;, 而在Java中,\又是特殊字符, 所以还要进行转义, 所以最终变成&quot;\\.&quot; */</span><br>            lineMap.put(twoStrs[<span class="hljs-number">0</span>], twoStrs[<span class="hljs-number">1</span>]);<br>        &#125;<br>        br.close();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= lineMap.size(); i++)&#123;<br>            String keyStr = String.valueOf(i); <span class="hljs-comment">//将数字key转换为字符串类型</span><br>            String valStr = lineMap.get(keyStr); <span class="hljs-comment">//查找对应的value字符串</span><br>            bw.write(keyStr + <span class="hljs-string">&quot;.&quot;</span> + valStr); <span class="hljs-comment">//写出段落</span><br>            bw.newLine(); <span class="hljs-comment">//换行！</span><br>        &#125;<br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-8-转换流"><a class="header-anchor" href="#13-8-转换流">¶</a>13.8 转换流</h2><h3 id="13-8-1-字符编码和字符集"><a class="header-anchor" href="#13-8-1-字符编码和字符集">¶</a>13.8.1 字符编码和字符集</h3><p><strong>字符编码</strong>(Character Encoding)：一套自然语言的字符与二进制数之间的对应规则。按其相应规则，将字符存储到计算机中，称为编码；将存储在计算机中的二进制数按照相应规则解析显示出来，称为解码。</p><p><strong>字符集</strong>(Charset)：也称编码表，是一个系统支持的所有字符的集合，包括各国文字、标点符号、图形符号、数字等。当指定其常见的字符集有：ASCII字符集、GBK字符集、Unicode字符集等。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201120221551.png"><p>当指定了编码，它所对应的字符集也即指定下来。</p><ul><li><p>ASCII 字符集 ：用于显示现代英文，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字、西文符号）。</p><ul><li>基本ASCII字符集使用7位表示一个字符（共128个）</li><li>拓展字符集使用8位表示一个字符（共256个）。</li></ul></li><li><p>ISO-8859-1 字符集：用于显示欧洲使用的语言。</p></li><li><p>GBxxx 字符集：用于显示中文而设计的一套字符集</p><ul><li>GBK：最常用的中文码表。</li><li>GB18030：最新的中文码表。每个字可由1个、2个或4个字节组成。</li></ul></li><li><p>Unicode 字符集：也称统一码、标准万国码，为表达任意语言的任意字符而设计。最多使用<strong>4个字节</strong>的数字来表达每个字母、符号或者文字。</p><ul><li><strong>UTF-8编码</strong>：最常用，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。其编码规则有：128个US-ASCII字符，只需一个字节编码；拉丁文等字符，需要二个字节编码；大部分常用字（含中文），使用三个字节编码；其他极少使用的Unicode辅助字符，使用四字节编码。</li><li>UTF-16</li><li>UTF-32</li></ul></li></ul><p>转换流即是字节与字符间的桥梁。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201120222727.png"><h3 id="13-8-2-InputStreamReader-类"><a class="header-anchor" href="#13-8-2-InputStreamReader-类">¶</a>13.8.2 InputStreamReader 类</h3><p>转换流<code>java.io.InputStreamReader</code>，是<code>Reader</code>子类，是从字节流到字符流的桥梁，利用它读入字节，并使用指定的字符集（由名称指定，可接受平台默认字符集），将其<strong>字节解码为字符</strong>。</p><p>构造方法：</p><ul><li><code>InputStreamReader(InputStream in, String charsetName)</code>：创建一个指定字符集的<strong>字符流</strong>。</li></ul><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201121004755.png"><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String myfile = <span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>; <span class="hljs-comment">// 定义文件路径,文件为gbk编码</span><br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(myfile)); <span class="hljs-comment">//创建流对象，默认UTF-8编码</span><br>        InputStreamReader isr2 = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(myfile), <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">//创建流对象，指定GBK编码</span><br>        <span class="hljs-keyword">int</span> b; <br>        <span class="hljs-keyword">while</span>((b = isr.read()) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//使用默认编码字符流读入，乱码</span><br>            System.out.println((<span class="hljs-keyword">char</span>)b); <span class="hljs-comment">//有可能出现乱码</span><br>        &#125;<br>        isr.close();<br>        <span class="hljs-keyword">while</span>((b = isr2.read()) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//使用指定编码字符流读入，正常解析</span><br>            System.out.println((<span class="hljs-keyword">char</span>)b); <span class="hljs-comment">//正常显示</span><br>        &#125;<br>        isr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-8-3-OutputStreamWriter-类"><a class="header-anchor" href="#13-8-3-OutputStreamWriter-类">¶</a>13.8.3 OutputStreamWriter 类</h3><p>转换流<code>java.io.OutputStreamWriter</code>，是<code>Writer</code>子类，是从字符流至字节流的桥梁，使用指定的字符集，将<strong>字符编码为字节</strong>。</p><p>构造方法：</p><ul><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>：创建一个指定字符集的字节流。</li></ul><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201121010328.png"><p>使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String myfile = <span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>;<br>        OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(myfile)); <span class="hljs-comment">//默认UTF-8编码</span><br>        osw.write(<span class="hljs-string">&quot;早安&quot;</span>); <span class="hljs-comment">//保存6个字节</span><br>        osw.close();<br>        String myfile_2 = <span class="hljs-string">&quot;E:\\IDEA-Projects\\123.txt&quot;</span>;<br>        OutputStreamWriter osw2 = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(myfile_2), <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">//指定GBK编码</span><br>        osw2.write(<span class="hljs-string">&quot;打工人&quot;</span>); <span class="hljs-comment">//保存为4个字节</span><br>        osw2.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-8-4-转换流应用：转换文件编码"><a class="header-anchor" href="#13-8-4-转换流应用：转换文件编码">¶</a>13.8.4 转换流应用：转换文件编码</h3><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String srcFile = <span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>;<br>        InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(srcFile), <span class="hljs-string">&quot;GBK&quot;</span>); <span class="hljs-comment">//转换输入流，指定GBK编码</span><br>        String destFile = <span class="hljs-string">&quot;E:\\IDEA-Projects\\233.txt&quot;</span>;<br>        OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(destFile));<span class="hljs-comment">//转换输出流，默认UTF-8编码</span><br><br>        <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len;<br>        <span class="hljs-keyword">while</span>((len = isr.read(cbuf)) != -<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//读入GBK编码的文本文件</span><br>            osw.write(cbuf, <span class="hljs-number">0</span>, len); <span class="hljs-comment">//写出UTF-8编码的文本文件</span><br>        &#125;<br>        osw.close();<br>        isr.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-9-序列化"><a class="header-anchor" href="#13-9-序列化">¶</a>13.9 序列化</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制，用一个字节序列表示一个对象，该字节序列包含该「对象的数据」、「对象的类型」和「对象中存储的数据」信息。当字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201121103052.png"><p>该字节序列还可从文件中读入，重构对象，对其进行<strong>反序列化</strong>。</p><h3 id="13-9-1-ObjectOutputStream-类"><a class="header-anchor" href="#13-9-1-ObjectOutputStream-类">¶</a>13.9.1 ObjectOutputStream 类</h3><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出至文件中，实现对象的持久存储。</p><p>构造方法：</p><ul><li><code>public ObjectOutputStream(OutputStream out)</code>：创建一个指定<code>OutputStream</code>的<code>ObjectOutputStream</code>。</li></ul><p>序列化操作：</p><ol><li><p>一个对象若想要序列化，必须同时满足两个条件：</p><ul><li><p>该类必须实现<code>java.io.Serializable</code> 接口（该接口是一个标记接口）。若不实现此接口的类，则不会使任何状态序列化或反序列化，抛出<code>NotSerializableException</code>。</p></li><li><p>该类所有属性必须是可序列化的，若有一个属性不需要可序列化，则该属性必须注明是<strong>瞬态</strong>的，使用<code>transient</code>关键字修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123; <span class="hljs-comment">//实现Serializable的接口</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String No;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> String address; <span class="hljs-comment">//transient瞬态修饰成员，不会被序列化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nameCheck</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学号为&quot;</span> + No + <span class="hljs-string">&quot;的学生姓名为：&quot;</span> + name);<br>    &#125;<br>&#125; <span class="hljs-comment">//为演示方便，部分方法暂忽略</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>写出对象的方法</p><ul><li><code>public final void writeObject(Object obj)</code>：将指定对象写出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student a = <span class="hljs-keyword">new</span> Student();<br>        a.name = <span class="hljs-string">&quot;Luffy&quot;</span>; a.No = <span class="hljs-string">&quot;23333&quot;</span>; a.address = <span class="hljs-string">&quot;Brazil&quot;</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>));<br>            oos.writeObject(a); <span class="hljs-comment">//写出对象，但注意该方法会抛出IO异常</span><br>            oos.close();<br>            System.out.println(<span class="hljs-string">&quot;Serialized data is saved successfully!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException i)&#123; <span class="hljs-comment">//捕获IO异常</span><br>            i.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="13-9-2-ObjectInputStream-类"><a class="header-anchor" href="#13-9-2-ObjectInputStream-类">¶</a>13.9.2 ObjectInputStream 类</h3><p><code>ObjectInputStream</code>反序列流，就之前使用的<code>ObjectOutputStream</code>序列化的原始数据恢复为对象。</p><p>构造方法：</p><ul><li><code>public ObjectInputStream(InputStream in)</code>：创建一个指定<code>InputStream</code>的<code>ObjectInputStream</code>。</li></ul><p>反序列化操作：</p><p>若能找到一个对象的<code>.class</code>文件，即可进行反序列化操作，调用<code>ObjectInputStream</code> 读入对象的方法：</p><ul><li><p><code>public final Object readObject()</code>：读入一个对象。注意，JVM反序列化对象时，必须能够找到传入的<code>.class</code>文件的类，否则抛出<code>ClassNotFoundException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student a = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            FileInputStream fileIn = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>);<br>            ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(fileIn); <span class="hljs-comment">//传入字节输入流参数</span><br>            a = (Student) ois.readObject(); <span class="hljs-comment">//读入对象，返回Object类需强转一下</span><br>            ois.close();<br>            fileIn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException i)&#123;<br>            i.printStackTrace();<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException c)&#123; <span class="hljs-comment">//readObject会抛出这类异常</span><br>            System.out.println(<span class="hljs-string">&quot;Student class can&#x27;t be found!&quot;</span>);<br>            c.printStackTrace();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Name:&quot;</span> + a.name + <span class="hljs-string">&quot; Address:&quot;</span> + a.address); <span class="hljs-comment">//若无异常则直接打印输出。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管JVM反序列化对象时能够找到<code>.class</code>，但注意<code>.class</code>文件在<strong>序列化对象之后</strong>发生了修改，则反序列化操作有可能失败，抛出个 <code>InvalidClassException</code> 异常。发生该异常的原因如下：</p><ul><li>该类的序列版本号与从流中读入的类描述符的<strong>版本号不匹配</strong>。</li><li>该类包含未知数据类型。</li><li>该类没有可访问的无参构造方法。</li></ul><p><code>Serializable</code> 接口给需要序列化的类提供一个默认的序列版本号<code>serialVersionUID</code>，该版本号目的在于验证序列化的对象和对应类是否版本匹配。当然，也可以自定义版本号，从而避免序列化后再修改<code>.class</code>文件所发生的冲突异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>&#123; <span class="hljs-comment">//实现Serializable的接口</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String No;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> String address; <span class="hljs-comment">//transient瞬态修饰成员，不会被序列化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>; <span class="hljs-comment">//加入序列版本号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> eid; <span class="hljs-comment">//假定我序列化之后再添加该属性再编译，是能够反序列化的（前提是你不能使用默认的序列版本号），该属性赋为默认值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nameCheck</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;学号为&quot;</span> + No + <span class="hljs-string">&quot;的学生姓名为：&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="13-9-3-序列化集合"><a class="header-anchor" href="#13-9-3-序列化集合">¶</a>13.9.3 序列化集合</h3><p>练习：将存有多个自定义对象的集合进行序列化，并保存至文件中。然后再反序列化该文件，遍历集合打印对象信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Student a = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Luffy&quot;</span>, <span class="hljs-string">&quot;001&quot;</span>);<br>        Student b = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Ben&quot;</span>, <span class="hljs-string">&quot;002&quot;</span>);<br>        Student c = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Nami&quot;</span>, <span class="hljs-string">&quot;003&quot;</span>);<br>        ArrayList&lt;Student&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        arr.add(a); arr.add(b); arr.add(c);<br>        serialise(arr); <span class="hljs-comment">//序列化</span><br><br>        <span class="hljs-comment">//反序列化</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>));<br>        ArrayList&lt;Student&gt; mylist = (ArrayList&lt;Student&gt;) ois.readObject();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mylist.size(); i++)&#123;<br>            Student cur = mylist.get(i);<br>            System.out.println(cur.getName() + <span class="hljs-string">&quot;---&quot;</span> + cur.getNo());<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialise</span><span class="hljs-params">(ArrayList&lt;Student&gt; arr)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\IDEA-Projects\\666.txt&quot;</span>));<br>        oos.writeObject(arr);<br>        oos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201121114318.png"><h2 id="13-10-打印流"><a class="header-anchor" href="#13-10-打印流">¶</a>13.10 打印流</h2><p>控制台打印输出即调用了<code>print()</code>/<code>println()</code>方法等，这些方法均来自于<code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值。</p><h3 id="13-10-1-PrintStream-类"><a class="header-anchor" href="#13-10-1-PrintStream-类">¶</a>13.10.1 PrintStream 类</h3><p><code>java.io.PrintStream</code>继承自父类<code>OutputStream</code>，故也有<code>close()</code>、<strong><code>write()</code></strong>、<code>flush()</code>等共性方法。</p><p>特点：</p><ol><li>只负责数据的<strong>输出</strong>，不负责数据的读取。</li><li>与其他输出流不同，它永远不会抛出<code>IOException</code>。（但还是能够抛出<code>FileNotFoundException</code> 异常）</li></ol><p>构造方法：</p><p>创建打印流<code>PrintStream</code>对象，其构造方法需传入 要输出的目的地（必须存在） 作为参数。</p><ul><li><code>public PrintStream(File file)</code>：输出目的地为一个文件。</li><li><code>public PrintStream(OutputStream out)</code>：输出目的地为一个字节输出流。</li></ul><p>特有方法：</p><ul><li><p><code>void print(任意类型)</code></p></li><li><p><code>void println(任意类型)</code>：输出包括换行</p><blockquote><p>若使用继承自父类的<code>write</code>方法写出数据，它会查询对应的编码表（如97-&gt;‘a’）并将其解码输出；若使用自己特有的方法<code>print()</code>或<code>println()</code>，写出的数据原样输出（如97-&gt;97）</p></blockquote></li></ul><p>另外，通过调用<code>System.setOut()</code>方法，可以将输出语句的目的地，改变为参数中传递的打印流的目的地（默认情况下，是控制台输出的）</p><ul><li><p><code>static void setOut(PrintStream out)</code>：重新分配“标准”输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在控制台输出！&quot;</span>);<br>        PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">&quot;C:\\Users\\admin\\IdeaProjects\\MyIdeaProjects\\666.txt&quot;</span>);<br>        System.out.println(ps);<br>        System.out.println(<span class="hljs-string">&quot;我在打印流的目的地中输出！&quot;</span>);<br>        ps.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Joy Dee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.joydee.top/posts/42f17ec5/">https://www.joydee.top/posts/42f17ec5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.joydee.top" target="_blank">JoyDee's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 不妨打赏一下？</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.joydee.cloud/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/bec882de/"><img class="prev-cover" src="/img/my-loading.jpg" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「汇编学习记录01」开发工具安装及编译运行第一个程序</div></div></a></div><div class="next-post pull-right"><a href="/posts/c11c98d4/"><img class="next-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「JavaSE学习笔记06」并发</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/a0f59037/" title="「JavaSE学习笔记04」异常"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-31</div><div class="title">「JavaSE学习笔记04」异常</div></div></a></div><div><a href="/posts/c11c98d4/" title="「JavaSE学习笔记06」并发"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-12</div><div class="title">「JavaSE学习笔记06」并发</div></div></a></div><div><a href="/posts/4775c8be/" title="「JavaSE学习笔记03」继承、接口、多态、内部类"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-25</div><div class="title">「JavaSE学习笔记03」继承、接口、多态、内部类</div></div></a></div></div></div><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/avatar.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Joy Dee</div><div class="author-info__description">Cause I have a dream.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/J-StrawHat"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/J-StrawHat" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:422148166@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/j_strawhat-2/" target="_blank" title="LeetCode"><i class="fas fa-code"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-box-open"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-13-IO%E6%B5%81"><span class="toc-text">Chapter 13. IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-File%E7%B1%BB"><span class="toc-text">13.1 File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">13.1.1 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-%E5%85%B3%E4%BA%8E%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">13.1.2 关于获取信息的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-3-%E5%85%B3%E4%BA%8E%E5%88%A4%E6%96%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">13.1.3 关于判断的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4-%E5%85%B3%E4%BA%8E%E5%88%9B%E5%BB%BA%E6%88%96%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">13.1.4 关于创建或删除的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-5-%E7%9B%AE%E5%BD%95%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">13.1.5 目录的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-6-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">13.1.6 文件过滤器的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-I-O%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-text">13.2 I&#x2F;O流概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-IO%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">13.2.1 IO的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">13.3 字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88OutputStream%EF%BC%89"><span class="toc-text">13.3.1 字节输出流（OutputStream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-2-FileOutputStream-%E7%B1%BB"><span class="toc-text">13.3.2 FileOutputStream 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-3-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88InputStream%EF%BC%89"><span class="toc-text">13.3.3 字节输入流（InputStream）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-4-FileInputStream-%E7%B1%BB"><span class="toc-text">13.3.4 FileInputStream 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-5-%E5%AD%97%E8%8A%82%E6%B5%81%E5%BA%94%E7%94%A8%EF%BC%9A%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6"><span class="toc-text">13.3.5 字节流应用：图片复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">13.4 字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E7%B1%BB%EF%BC%88Reader%EF%BC%89"><span class="toc-text">13.4.1 字符输入类（Reader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-2-FileReader-%E7%B1%BB"><span class="toc-text">13.4.2 FileReader 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-3-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88Writer%EF%BC%89"><span class="toc-text">13.4.3 字符输出流（Writer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-4-FileWriter-%E7%B1%BB"><span class="toc-text">13.4.4 FileWriter 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-IO-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">13.5 IO 异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-1-JDK7%E5%89%8D%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">13.5.1 JDK7前的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-2-JDK7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">13.5.2 JDK7的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-%E5%B1%9E%E6%80%A7%E9%9B%86"><span class="toc-text">13.6 属性集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanUtils-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">BeanUtils 工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">13.7 缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-1-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">13.7.1 字节缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-2-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">13.7.2 字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-7-3-%E7%BC%93%E5%86%B2%E6%B5%81%E5%BA%94%E7%94%A8%EF%BC%9A%E6%96%87%E6%9C%AC%E6%8E%92%E5%BA%8F"><span class="toc-text">13.7.3 缓冲流应用：文本排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">13.8 转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-1-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">13.8.1 字符编码和字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-2-InputStreamReader-%E7%B1%BB"><span class="toc-text">13.8.2 InputStreamReader 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-3-OutputStreamWriter-%E7%B1%BB"><span class="toc-text">13.8.3 OutputStreamWriter 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-8-4-%E8%BD%AC%E6%8D%A2%E6%B5%81%E5%BA%94%E7%94%A8%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81"><span class="toc-text">13.8.4 转换流应用：转换文件编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-9-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">13.9 序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-1-ObjectOutputStream-%E7%B1%BB"><span class="toc-text">13.9.1 ObjectOutputStream 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-2-ObjectInputStream-%E7%B1%BB"><span class="toc-text">13.9.2 ObjectInputStream 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-9-3-%E5%BA%8F%E5%88%97%E5%8C%96%E9%9B%86%E5%90%88"><span class="toc-text">13.9.3 序列化集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-10-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">13.10 打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-10-1-PrintStream-%E7%B1%BB"><span class="toc-text">13.10.1 PrintStream 类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-car"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/cd115ce8/" title="Tensor基础操作"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Tensor基础操作"></a><div class="content"><a class="title" href="/posts/cd115ce8/" title="Tensor基础操作">Tensor基础操作</a><time datetime="2021-07-30T04:16:41.000Z" title="发表于 2021-07-30 12:16:41">2021-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a3d64eab/" title="机器学习与深度学习概述"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="机器学习与深度学习概述"></a><div class="content"><a class="title" href="/posts/a3d64eab/" title="机器学习与深度学习概述">机器学习与深度学习概述</a><time datetime="2021-07-29T21:16:41.000Z" title="发表于 2021-07-30 05:16:41">2021-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6db2ac7/" title="Ubuntu 18.04 安装配置 Anaconda3、PyTorch、Jupyter Notebook"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ubuntu 18.04 安装配置 Anaconda3、PyTorch、Jupyter Notebook"></a><div class="content"><a class="title" href="/posts/6db2ac7/" title="Ubuntu 18.04 安装配置 Anaconda3、PyTorch、Jupyter Notebook">Ubuntu 18.04 安装配置 Anaconda3、PyTorch、Jupyter Notebook</a><time datetime="2021-07-28T20:16:41.000Z" title="发表于 2021-07-29 04:16:41">2021-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1701cff7/" title="Pandas 库的使用"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pydatascience.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Pandas 库的使用"></a><div class="content"><a class="title" href="/posts/1701cff7/" title="Pandas 库的使用">Pandas 库的使用</a><time datetime="2021-07-28T08:34:00.000Z" title="发表于 2021-07-28 16:34:00">2021-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1701cff7/" title="Matplotlib 库的使用"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pydatascience.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Matplotlib 库的使用"></a><div class="content"><a class="title" href="/posts/1701cff7/" title="Matplotlib 库的使用">Matplotlib 库的使用</a><time datetime="2021-07-27T09:11:43.000Z" title="发表于 2021-07-27 17:11:43">2021-07-27</time></div></div></div></div></div></div></main><footer id="footer" style="background:#393d49"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Joy Dee</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you learn something in my blog and leave your comment!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论区"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章中的关键词" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/copy-tex.min.css"><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.joydee.top/",region:"",katex:{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1}},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo.joydee.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},i=(i=!1)=>{"object"==typeof twikoo?(o(),i&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),i&&t&&setTimeout(e,0)})};i(!0)})()</script></div><script>window.addEventListener("load",()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}'>${e[n].content}</a>\n        <div class='name'><span>${e[n].nick} / </span><time datetime="${e[n].date}">${btf.diffDate(e[n].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.joydee.top/",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map(e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t});saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),15/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)})</script><script src="https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax",".tk-comments-container"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","UA-184747878-1",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>