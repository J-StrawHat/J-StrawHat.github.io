<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「JavaSE学习笔记02」对象与类 | JoyDee's Blog</title><meta name="keywords" content="JavaSE"><meta name="author" content="Joy Dee"><meta name="copyright" content="Joy Dee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶Chapter 4. 对象与类 ¶4.1 面向对象程序设计概述 面向对象程序设计（简称OOP），是当今主流程序设计范型。面向对象的程序是由对象组成的，每个对象（来自于标准库或自定义的）包含对用户公开的特定功能和隐藏的实现部分。在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。面向对象的语言中，包含了三大基本特征：封装、继承、多态。 ¶4.1.1 类 类(class)，是构造对象的模"><meta property="og:type" content="article"><meta property="og:title" content="「JavaSE学习笔记02」对象与类"><meta property="og:url" content="https://www.joydee.top/posts/548f7542/index.html"><meta property="og:site_name" content="JoyDee&#39;s Blog"><meta property="og:description" content="¶Chapter 4. 对象与类 ¶4.1 面向对象程序设计概述 面向对象程序设计（简称OOP），是当今主流程序设计范型。面向对象的程序是由对象组成的，每个对象（来自于标准库或自定义的）包含对用户公开的特定功能和隐藏的实现部分。在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。面向对象的语言中，包含了三大基本特征：封装、继承、多态。 ¶4.1.1 类 类(class)，是构造对象的模"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif"><meta property="article:published_time" content="2020-10-23T06:27:00.000Z"><meta property="article:modified_time" content="2021-08-04T15:40:43.536Z"><meta property="article:author" content="Joy Dee"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.joydee.top/posts/548f7542/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><meta name="google-site-verification" content="FcqPwEYbr_cknqo4XYD1DIbaczUgJwPf9WVNALOG_rA"><meta name="baidu-site-verification" content="code-BTKhd4k3xT"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3c4988fb9892b3bebf918781af0b8ace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-184747878-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-184747878-1")</script><link rel="stylesheet" href="https://fonts.font.im/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:700},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Joy Dee",link:"链接: ",source:"来源: JoyDee's Blog",info:"本文为作者的原创文章。遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#0483fa",bgDark:"#00c4b6",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"「JavaSE学习笔记02」对象与类",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-08-04 23:40:43"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/joydee.css"><link rel="stylesheet" href="/css/night-owl.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@latest/pace-theme-default.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JoyDee's Blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/avatar.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">112</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-layer-group"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://music.apple.com/cn/browse"><i class="fa-fw fas fa-music"></i> <span>Apple Music</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://portal.qiniu.com/home"><i class="fa-fw fas fa-images"></i> <span>七牛云图床</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/DesertsP/Valine-Admin"><i class="fa-fw fas fa-comments"></i> <span>评论后台管理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JoyDee's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-layer-group"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://music.apple.com/cn/browse"><i class="fa-fw fas fa-music"></i> <span>Apple Music</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://portal.qiniu.com/home"><i class="fa-fw fas fa-images"></i> <span>七牛云图床</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/DesertsP/Valine-Admin"><i class="fa-fw fas fa-comments"></i> <span>评论后台管理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="coverdiv"><img id="post-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"></div><div id="post-info"><div id="post-categories-container"><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JavaSE/">JavaSE</a></span></div><h1 class="post-title">「JavaSE学习笔记02」对象与类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-23T06:27:00.000Z" title="发表于 2020-10-23 14:27:00">2020-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-04T15:40:43.536Z" title="更新于 2021-08-04 23:40:43">2021-08-04</time></span><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="fas fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span></span><span class="post-meta-separator">|</span><span data-flag-title="「JavaSE学习笔记02」对象与类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="fas fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/548f7542/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-4-对象与类"><a class="header-anchor" href="#Chapter-4-对象与类">¶</a>Chapter 4. 对象与类</h1><h2 id="4-1-面向对象程序设计概述"><a class="header-anchor" href="#4-1-面向对象程序设计概述">¶</a>4.1 面向对象程序设计概述</h2><p><strong>面向对象程序设计</strong>（简称<em>OOP</em>），是当今主流程序设计范型。面向对象的程序是由对象组成的，每个对象（来自于标准库或自定义的）包含对用户公开的特定功能和隐藏的实现部分。在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。面向对象的语言中，包含了<strong>三大基本特征</strong>：封装、继承、多态。</p><h3 id="4-1-1-类"><a class="header-anchor" href="#4-1-1-类">¶</a>4.1.1 类</h3><p>类(<em>class</em>)，是构造对象的<strong>模板或蓝图</strong>。由类构造(<em>construct</em>)对象的过程，成为<strong>类的实例</strong>(<em>instance</em>)。</p><p>封装(<em>encapsulation</em>)，给予对象“黑盒”特征，将数据与行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据成为<strong>实例域</strong>(<em>instance fields</em>)，操纵数据的过程成为<strong>方法</strong>(<em>method</em>)。对于每个特定的类实例（对象）都有一组特定的实例域值，这些值的集合就是这个对象的当前状态。</p><p>类之间，最常用的关系：</p><ul><li><p>依赖（<em>“uses-a”</em>）——一个类的方法操纵另一个类的对象</p><blockquote><p>应尽可能将相互依赖的类减至最小。若类A不知道B的存在，它就不关心B的任何改变（即不会导致A产生BUG）。用软件工程的术语来说，就是<strong>让类之间的耦合度最小</strong>。</p></blockquote></li><li><p>聚合（<em>“has-a”</em>）——意味着类A的对象包含类B的对象</p></li><li><p>继承（<em>“is-a”</em>）——若类A拓展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。</p></li></ul><h3 id="4-1-2-对象"><a class="header-anchor" href="#4-1-2-对象">¶</a>4.1.2 对象</h3><p>对象，是类的实体。它是一类事物的具体体现，它必然具备某类事物的属性和行为。</p><p>要想使用OOP，需清楚<strong>对象</strong>的三个<strong>主要特性</strong>：</p><ul><li>对象的行为——可对对象施加哪些操作或哪些方法？</li><li>对象的状态——当施加那些方法时，对象如何响应？</li><li>对象标识——如何辨识具有相同行为与状态的不同对象？</li></ul><p>同一个类的所有对象实例，由于支持相同行为而具有家族相似性。对象的行为是用可调用的方法定义的。</p><p>此外，每个对象都保存着描述当前特征的信息，即对象的状态。对象状态的改变必须通过<strong>调用方法</strong>实现。（若不经方法调用就改变对象状态，说明封装性遭破坏）</p><p>但是，对象的状态并不能完全描述一个对象，每个对象均有一个唯一的身份。需注意，作为一个类的实例，每个对象的标识<strong>永远不同</strong>，状态<strong>常常存在差异</strong>。</p><h2 id="4-2-对象与类的相关操作"><a class="header-anchor" href="#4-2-对象与类的相关操作">¶</a>4.2 对象与类的相关操作</h2><p>我们接下来编写的主力类(<em>workhorse class</em>)，没有<code>main</code>方法而却有自定义的实例域和实例方法。若要创建一个完整的程序，应将若干类组合在一起，其中只有一个类有<code>main</code>方法。</p><p>Java中，一个源文件<strong>只能有一个</strong>公有类。但可以有任意个非公有类。许多程序员习惯将每一个类存在一个单独的源文件中。</p><h3 id="4-2-1-最简单的类的定义"><a class="header-anchor" href="#4-2-1-最简单的类的定义">¶</a>4.2.1 最简单的类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在Phone.java文件中</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;<br>    <span class="hljs-comment">//成员变量</span><br>    String brand, color;<br>    <span class="hljs-keyword">double</span> price;<br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String sb)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;给&quot;</span> + sb + <span class="hljs-string">&quot;打电话&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;群发短信&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ol><li>成员变量是直接定义在类内部，在方法外部。若成员变量没有进行复制，那么会有默认值（规则与数组相同）</li><li>成员方法不用写<code>static</code>关键字。</li><li>在Java中，所有方法都必须在<strong>类的内部</strong>定义，但并不表示它们是内联方法（这交给Java虚拟机去解决）。</li></ol><p>局部变量与成员变量的区别：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">局部变量</th><th style="text-align:center">成员变量</th></tr></thead><tbody><tr><td style="text-align:center">定义位置</td><td style="text-align:center">方法内部</td><td style="text-align:center">方法外部、写于类内部</td></tr><tr><td style="text-align:center">内存位置</td><td style="text-align:center">栈内存</td><td style="text-align:center">堆内存</td></tr><tr><td style="text-align:center">作用域</td><td style="text-align:center">只有在方法当中可以使用</td><td style="text-align:center">在整个类均可使用</td></tr><tr><td style="text-align:center">生命周期</td><td style="text-align:center">随方法进栈而诞生（随方法出栈而消失）</td><td style="text-align:center">随对象创建而诞生（随对象被垃圾回收而消失）</td></tr><tr><td style="text-align:center">默认值</td><td style="text-align:center">无默认值，若要使用则必须赋值。</td><td style="text-align:center">若没有赋值，则会<strong>自带默认值</strong>。</td></tr></tbody></table><h3 id="4-2-2-标准类（Java-Bean）的定义"><a class="header-anchor" href="#4-2-2-标准类（Java-Bean）的定义">¶</a>4.2.2 标准类（Java Bean）的定义</h3><p>标准的类，也称<em>Java Bean</em>。它需满足：</p><ul><li><p>都要使用<code>private</code>关键字修饰，相应地，需为每一成员变量编写一对<code>Getter/Setter</code>方法。（详见下方的4.3）</p></li><li><p>类需要编写一个无参数的构造方法与一个全参数的构造方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-comment">//1. 构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//无参构造方法</span><br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">19</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123; <span class="hljs-comment">//全参构造方法</span><br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">//2. Getter和Setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">//2. 成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用IDEA来生成相应方法：(以<code>Getter/Setter</code>为例，若要生成构造方法同理）</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201024113806.png"><p>选择你需要生成的方法类型，此处选中<code>Getter和Setter</code>，得到下面窗口。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201024113954.png"><p>下图即为生成成功。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20201024114026.png"><blockquote><p>TIPS：有些程序员会为每个参数前面加上一个前缀&quot;a&quot;。如：<code>public Employee(String aName, double aSalary)</code>，十分清晰。</p><p>C++中一般用下划线作为实例域的前缀（<s>确实</s>），如<code>salary</code>域会被命名为<code>_salary</code>。但Java程序员通常不这样做。</p></blockquote><h3 id="4-2-3-对象的构造方法"><a class="header-anchor" href="#4-2-3-对象的构造方法">¶</a>4.2.3 对象的构造方法</h3><p>构造方法（构造器）就是专门用于创建对象的方法，当我们通过关键字<code>new</code>来创建对象时，实际上就是在调用构造方法。其格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> 类名称(参数类型 参数名称, ... )&#123;<br>    方法体<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ol><li>仅当类没有提供任何构造方法的时候，系统才会提供一个默认的构造方法。（一旦编写了至少一个构造方法，系统则不再提供）</li><li>构造方法的名称必须与所在的类名称完全一样（包括大小写）。</li><li>构造方法不要写返回值类型（连<code>void</code>都不写），当然也不能<code>return</code>一个具体的返回值。</li><li>构造方法总是伴随<code>new</code>操作一起调用。</li></ol><h3 id="4-2-4-对象的创建与使用"><a class="header-anchor" href="#4-2-4-对象的创建与使用">¶</a>4.2.4 对象的创建与使用</h3><p>我们知道，一个类并不能直接使用，需要根据类创建一个对象，方能使用。</p><ol><li><p>导包：指出需要使用的类在哪里</p><p>格式：<code>import 包名称.类名称;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> day03.demo1.Student; <span class="hljs-comment">//别漏分号</span><br></code></pre></td></tr></table></figure><p>注：对于和当前类属于同一个包的情况，可省略不写导包语句</p><blockquote><p>在Java中，<code>package</code>与<code>import</code>语句，类似于C++中<code>namespace</code>和<code>using</code> 指令</p></blockquote></li><li><p>创建</p><p>格式：<code>类名称 对象名 = new 类名称()</code> 或者 <code>类名称 对象名 = new 类名称(参数1, 参数2, ...)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Student stu = <span class="hljs-keyword">new</span> Student();<br></code></pre></td></tr></table></figure></li><li><p>使用</p><p>(在没有<code>Setter&amp;Getter</code>的情况下)使用成员变量：<code>对象名.成员变量名</code></p><p>使用成员方法：<code>对象名.成员方法名(参数1, 参数2, ...)</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在Demo01PhoneOne.java文件中</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01PhoneOne</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Phone one = <span class="hljs-keyword">new</span> Phone();<br>        System.out.println(one.brand);<br>        one.brand = <span class="hljs-string">&quot;苹果&quot;</span>;<br>        one.call(<span class="hljs-string">&quot;Cook&quot;</span>);<br>        one.sendMessage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="附-几个对象的内存图"><a class="header-anchor" href="#附-几个对象的内存图">¶</a>[附]几个对象的内存图</h3><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/02-两个对象使用同一个方法的内存图.png"> <img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/03-两个引用指向同一个对象的内存图.png"><p>在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的<strong>引用</strong>。<code>new</code>操作符的返回值也是一个引用。</p><blockquote><p>可以将Java对象变量看作C++的对象指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Date birthday; <span class="hljs-comment">//Java;</span><br>等同于<br>Date* birthday; <span class="hljs-comment">//C++</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="4-2-5-匿名对象"><a class="header-anchor" href="#4-2-5-匿名对象">¶</a>4.2.5 匿名对象</h3><p>格式：<code>new 类名称();</code></p><p>注意事项：匿名对象只能使用唯一一次，下次再使用时必须创建一个新对象。</p><p>使用建议：若确定有一个对象只需要使用唯一的一次，便可用匿名对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-keyword">new</span> Scanner(System.in).nextInt();<br>methodParam(<span class="hljs-keyword">new</span> Scanner(System.in)); <span class="hljs-comment">//使用匿名对象来进行传参</span><br></code></pre></td></tr></table></figure><h3 id="4-2-6-静态static关键字"><a class="header-anchor" href="#4-2-6-静态static关键字">¶</a>4.2.6 静态static关键字</h3><p>若类中的某个成员变量或方法用<code>static</code>关键字修饰，则以后创建的对象中的<code>static</code>修饰的变量或方法不再属于对象自己，而是属于类，也就说凡是本类的对象，都共享同一份。</p><p>无论是成员变量，还是成员方法。若有了<code>static</code>修饰，都推荐使用<strong>类名称</strong>进行调用。</p><ul><li><p><code>static</code>关键字修饰成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* Student.java文件中 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">static</span> String room;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> idCounter = <span class="hljs-number">0</span>;<span class="hljs-comment">//学号计数器，每new一个新对象便自增</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.id = ++idCounter;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = ++idCounter;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* JustTest.java文件中 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student one = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Luffy&quot;</span>);<br>        one.room = <span class="hljs-string">&quot;101教室&quot;</span>;<br><br>        System.out.printf(<span class="hljs-string">&quot;%s的学号为：%d,教室为：%s\n&quot;</span>, one.getName(), one.getId(), one.getRoom());<br>        Student two = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Nami&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;%s的学号为：%d,教室为：%s\n&quot;</span>, two.getName(), two.getId(), two.getRoom());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>static</code>关键字修饰成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* MyClass.java文件中 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numStatic; <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//成员方法</span><br>        System.out.println(<span class="hljs-string">&quot;我是成员方法！&quot;</span>);<br>        System.out.println(num); <span class="hljs-comment">//成员方法可访问成员变量</span><br>        System.out.println(numStatic); <span class="hljs-comment">//成员方法可访问静态变量</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodStatic</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//静态方法</span><br>        System.out.println(<span class="hljs-string">&quot;我是静态方法！&quot;</span>);<br>        <span class="hljs-comment">//System.out.println(num); 错误写法！静态方法不能访问非静态变量</span><br>        System.out.println(numStatic); <span class="hljs-comment">//静态方法可访问静态变量</span><br>        <span class="hljs-comment">//System.out.println(this); 错误写法！静态方法不能使用this关键字</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* JustTest.java文件中 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyClass obj = <span class="hljs-keyword">new</span> MyClass(); <span class="hljs-comment">//创建对象方能使用非静态的成员方法</span><br>        obj.method();<br>        obj.methodStatic(); <span class="hljs-comment">//正确，但不推荐</span><br>        MyClass.methodStatic(); <span class="hljs-comment">//对于静态方法，可直接通过类名称来调用</span><br><br>        myMethod(); <span class="hljs-comment">//本类当中的静态方法，可直接省略类名称</span><br>        JustTest.myMethod(); <span class="hljs-comment">//完全等效</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是我的方法！&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>静态代码块</p><p>格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名称</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//静态代码块中的内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ol><li><p>一旦第<strong>一次</strong>使用了该类的静态代码块，该静态代码块以后都不再执行</p><blockquote><p>静态代码块的典型用途：用于一次性地对静态成员变量进行赋值</p></blockquote></li><li><p>静态内容总是<strong>优先</strong>于非静态，故静态代码块比构造方法更早执行。</p></li></ol></li></ul><h2 id="4-3-封装"><a class="header-anchor" href="#4-3-封装">¶</a>4.3 封装</h2><p>封装性在Java中的体现：</p><ul><li>方法是一种封装；</li><li>关键字<code>private</code>也是一种封装。</li></ul><p>一旦使用<code>private</code>进行修饰，那么本类当中仍然可以随意访问。但是，超出本类范围之外，不能再直接访问了。要间接访问<code>private</code>成员变量，就是定义一对<code>Getter/Setter</code>方法。</p><ul><li><p>仅访问实例域而不进行修改的方法，称之为<strong>访问器方法</strong>（<em>accessor method</em>）。在Java中，对应为<code>Getter</code>，不能有参数，返回值类型和成员变量相对应。命令规则一般为<code>getXXX</code>（若为<code>boolean</code>类型，则应命名为<code>isXXX</code>）。eg: <code>getTime</code></p></li><li><p>对实例域做出修改的方法，称之为<strong>更改器方法</strong>（<em>mutator method</em>）。在Java中，对应为<code>Setter</code>，不能有返回值，参数类型与成员变量相对应。命令规则一般为<code>setXXX</code>。eg:<code>setTime</code></p></li></ul><p>如此封装的好处：</p><ol><li>可改变内部实现，除了该类的方法之外，不会影响其他代码。</li><li>更改器方法可以执行<strong>错误检查</strong>，然而直接对域进行赋值将不会进行这些处理。</li></ol><h3 id="4-3-1-this"><a class="header-anchor" href="#4-3-1-this">¶</a>4.3.1 this</h3><p><code>this</code>关键字可以用来访问本类的内容。</p><p>一、在本类的成员方法中，访问本类的成员<strong>变量</strong>。</p><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;, 你好。我是&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了解决上方产生的“二义性”，希望在本类的某个方法中访问<strong>本类</strong>当中的成员变量，需使用<code>this.成员变量名</code>。在每一个方法中，关键字<code>this</code>表示隐式参数。</p><p>即将上面代码块的第四行改为：<code>System.out.println(name + &quot;，你好。我是&quot; + this.name);</code></p><p>二、在本类的成员方法中，访问本类的另一个成员<strong>方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodA</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A!&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodB</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.methodA();<br>        System.out.println(<span class="hljs-string">&quot;B!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三、在本类的构造方法中，访问本类的另一个构造方法。</p><p>注意：<code>this()</code>调用必须是构造方法的第一个语句，且是唯一一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">//本类的无参构造，调用本类的有参构造方法。</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span></span>&#123;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-Scanner类"><a class="header-anchor" href="#4-4-Scanner类">¶</a>4.4 Scanner类</h2><p>通过Scanner类的学习，我们能够熟悉如何查询API，如何使用现有的类。</p><h3 id="4-4-1-引用类型的使用步骤"><a class="header-anchor" href="#4-4-1-引用类型的使用步骤">¶</a>4.4.1 引用类型的使用步骤</h3><ol><li><p>导包</p><p>格式：<code>import 包路径.类名称;</code></p><blockquote><p>只有<code>java.lang</code>包下的内容不需要导包，其他的包均需要<code>import</code>语句。</p></blockquote></li><li><p>创建</p><p>格式：<code>对象名 = new 类名称(参数1,...);</code></p></li><li><p>使用</p><p>格式：<code>对象名.成员方法名()</code></p></li></ol><h3 id="4-4-2-概述"><a class="header-anchor" href="#4-4-2-概述">¶</a>4.4.2 概述</h3><p><code>Scanner</code>类，是一个可以解析基本类型和字符串的简单文本扫描器。它可以实现键盘输入数据到程序当中。</p><p>关于<code>Scanner</code>类的导包语句为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br></code></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyPackages;<br><span class="hljs-keyword">import</span> java.util.Scanner; <span class="hljs-comment">//1. 导包</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01Scanner</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//2. 创建对象。Note: System.in代表从键盘进行输入</span><br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in); <br>        <span class="hljs-comment">//3. 获取键盘输入的字符串</span><br>        String str = sc.next();<br>        <span class="hljs-comment">//4. 获取键盘输入的任何字符串，同时转换为int类型</span><br>        <span class="hljs-keyword">int</span> a = sc.nextInt();<br>        <br>        <span class="hljs-keyword">int</span> num = <span class="hljs-keyword">new</span> Scanner(System.in).nextInt(); <span class="hljs-comment">//简写 </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-Random类"><a class="header-anchor" href="#4-5-Random类">¶</a>4.5 Random类</h2><p><code>Random</code>类用于生成随机数字。</p><p><code>Random</code>导包语句为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br></code></pre></td></tr></table></figure><p>创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Random r = <span class="hljs-keyword">new</span> Random(); <br></code></pre></td></tr></table></figure><p>使用：</p><ol><li><p>获取一个随机<code>int</code>型数字，其范围为<code>int</code><strong>所有范围，含正负</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = r.nextInt();<br></code></pre></td></tr></table></figure></li><li><p>获取一个随机<code>int</code>型数字，传入参数代表右区间界线。范围为<strong>左闭右开</strong>区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = r.nextInt(<span class="hljs-number">3</span>); <span class="hljs-comment">//实际上范围为0,1,2</span><br></code></pre></td></tr></table></figure><blockquote><p>由于是左闭右开区间，如果我们想要得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span>的随机数，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">r.nextInt(b + <span class="hljs-number">1</span>);<br>r.nextInt(b + <span class="hljs-number">1</span>) + a;<br><span class="hljs-comment">//本来范围为[0, b]，现在整体加a，范围变为[a, b + a];</span><br><span class="hljs-comment">//为了得到[a,b]，则对传入参数-a即可。</span><br>r.nextInt(b - a + <span class="hljs-number">1</span>) + a;<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="4-6-泛型数组列表：ArrayList集合"><a class="header-anchor" href="#4-6-泛型数组列表：ArrayList集合">¶</a>4.6 泛型数组列表：ArrayList集合</h2><h3 id="4-6-1-引入——对象数组"><a class="header-anchor" href="#4-6-1-引入——对象数组">¶</a>4.6.1 引入——对象数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Person类的代码就不放了，现在InstanceOfArray.java文件中，</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceOfArray</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] a = <span class="hljs-keyword">new</span> Person[<span class="hljs-number">3</span>];<br>        System.out.println(a);<br>        System.out.println(a[<span class="hljs-number">0</span>]); <span class="hljs-comment">//输出为null</span><br>        <span class="hljs-comment">//由于a[0],...未分配相应的空间，默认值为null。不能直接对a[0]的成员进行修改，故11行与12行的代码会发生报错！</span><br>        <span class="hljs-comment">//a[0].name = &quot;张三&quot;;</span><br>        <span class="hljs-comment">//a[0].age = 18;</span><br>        <span class="hljs-comment">//正确应有：</span><br>        a[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Luffy&quot;</span>, <span class="hljs-number">19</span>);<br>        System.out.println(a[<span class="hljs-number">0</span>].getAge());<br>        System.out.println(a[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于数组无法在运行过程中改变其本身的规模，此处即引入下一节要介绍的<code>ArrayList</code>类。</p><h3 id="4-6-2-概述"><a class="header-anchor" href="#4-6-2-概述">¶</a>4.6.2 概述</h3><p><code>ArrayList</code>：一种可以动态增长和缩减的索引序列，称为数组列表。在Java SE5.0中，它是一个采用类型参数的<strong>泛型类</strong>。为了指定数组列表保存的元素对象类型，需要用<code>&lt;&gt;</code>将类名括起来加在后面。例如<code>ArrayList &lt;Employee&gt;</code></p><blockquote><p>泛型——装在集合当中所有元素，全部是统一的类型。但注意，泛型只能是<strong>引用类型</strong>，不能是基本类型（因为集合保存的均是引用类型的值）</p></blockquote><blockquote><p><code>ArrayList</code>类似于C++的<code>vector</code>模板，它与<code>vector</code>都是泛型类型。但由于Java没有运算符重载，所以它不像<code>vector</code>模板为了便于访问元素重载<code>[]</code>运算符。此外，<code>vector</code>向量是值拷贝，而在Java中，<code>a=b</code>的赋值语句的操作结果，是让<code>a</code>和<code>b</code>引用同一个数组列表。</p><p>另外，<code>java.util.List</code>正是<code>ArrayList</code>所实现的接口。</p></blockquote><h3 id="4-6-3-数组列表的相关操作"><a class="header-anchor" href="#4-6-3-数组列表的相关操作">¶</a>4.6.3 数组列表的相关操作</h3><p>一、创建某个类型的<code>ArrayList</code>集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; listA = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>ArrayList&lt;String&gt; listB = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><blockquote><p>对于<code>ArrayList</code>而言，直接打印得到的不是地址值，而是其内容，若内容为空，则得到空的中括号。</p></blockquote><p>二、向集合添加元素：</p><p><code>public boolean add(E e)</code>：向集合当中添加元素，参数类型与泛型一致，返回值为<code>boolean</code>表示是否添加成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">listA.add(<span class="hljs-string">&quot;ONEPIECE&quot;</span>);<br>listA.add(<span class="hljs-string">&quot;I got it&quot;</span>);<br><span class="hljs-comment">//运行结果为</span><br><span class="hljs-comment">//[ONEPIECE, I got it] </span><br><span class="hljs-comment">//两边的中括号是输出时它本身自带的，输出中元素之间的&#x27;,&#x27;号也是本身自带的。</span><br></code></pre></td></tr></table></figure><p>三、通过索引值从集合中获取元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = listA.get(<span class="hljs-number">4</span>); <span class="hljs-comment">//索引值从0开始，返回值即为编号对应的元素</span><br></code></pre></td></tr></table></figure><p>四、从集合当中删除元素，参数为索引编号，返回值为被删除的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String whoRemoved = listA.remove(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>五、遍历集合中的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; listA.size(); i++)&#123;<br>    <span class="hljs-comment">//do something;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>六、集合作为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">getSmallList</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="4-6-4-数组列表存储基本类型数据-与-包装类"><a class="header-anchor" href="#4-6-4-数组列表存储基本类型数据-与-包装类">¶</a>4.6.4 数组列表存储基本类型数据 与 包装类</h3><p>如果希望向集合<code>ArrayList</code>当中存储基本类型数据，则必须使用基本类型所对应的<strong>包装类</strong>。</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">包装类</th></tr></thead><tbody><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>Integer</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>Character</code></td></tr><tr><td style="text-align:center"><code>byte</code></td><td style="text-align:center"><code>Byte</code></td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center"><code>Long</code></td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center"><code>short</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>Double</code></td></tr><tr><td style="text-align:center"><code>boolean</code></td><td style="text-align:center"><code>Boolean</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>Float</code></td></tr></tbody></table><p>举例使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo05</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ArrayList&lt;Integer&gt; listA = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        listA.add(<span class="hljs-number">100</span>);<br>        listA.add(<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">int</span> cur = listA.get(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>ArrayList&lt;Integer&gt;</code>的效率远远低于<code>int[]</code>数组，因此应该用它构造小型集合。</p></blockquote><p>从JDK 1.5+开始，支持自动打包（<em>autoboxing</em>）（即 基本类型 –&gt; 包装类型）、自动拆包（即 包装类型 –&gt; 基本类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">233</span>; <span class="hljs-comment">//自动打包，相当于Integer i = Integer.valueOf(233);</span><br>i = i + <span class="hljs-number">66</span>; <span class="hljs-comment">//等号右边是将i对象转换成基本数据类型（自动拆包），i.intValue() + 66;</span><br></code></pre></td></tr></table></figure><h2 id="4-7-String类"><a class="header-anchor" href="#4-7-String类">¶</a>4.7 String类</h2><p>Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类<code>String</code>，它与C++中的字符串有很大的差异。</p><p>每个用双引号括起来的字符串都是（如<code>&quot;abcd&quot;</code>）<code>String</code>类的一个实例。</p><p>特点：</p><ol><li><p>字符串是<strong>常量</strong>，它们的值在创建之后不能更改！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String strA = <span class="hljs-string">&quot;Hello&quot;</span>;<br>strA = <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">//上面的写法中，字符串的内容仍然没有改变，这样的写法是修改字符串变量strA，让它应用另外一个字符串。相当于将存放3的数值变量改成存放4一样</span><br></code></pre></td></tr></table></figure></li><li><p>字符串是<strong>共享使用</strong>的。</p></li></ol><h3 id="4-7-1-字符串的构造方法和直接创建"><a class="header-anchor" href="#4-7-1-字符串的构造方法和直接创建">¶</a>4.7.1 字符串的构造方法和直接创建</h3><p>创建字符串的几种方式：</p><ul><li><p>直接创建（无需使用<code>new</code>）：<code>String str = &quot;Hello!&quot;;</code></p></li><li><p>创建一个空白字符串，不含任何内容：<code>public String();</code></p></li><li><p>根据字符数组的内容，来创建对应的字符串：<code>public String(char[] array);</code></p></li><li><p>根据字节数组的内容，来创建对应的字符串：<code>public String(byte[] array);</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoString</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String str0 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <br>        String str1 = <span class="hljs-keyword">new</span> String();<br>        <br>        <span class="hljs-keyword">char</span>[] charArray = &#123;<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>&#125;;<br>        String str2 = <span class="hljs-keyword">new</span> String(charArray);<br>     <br>        <span class="hljs-keyword">byte</span>[] byteArray = &#123;<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>&#125;;<br>        String str3 = <span class="hljs-keyword">new</span> String(byteArray);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-7-2-字符串常量池、检测字符串是否相等"><a class="header-anchor" href="#4-7-2-字符串常量池、检测字符串是否相等">¶</a>4.7.2 字符串常量池、检测字符串是否相等</h3><p><code>String</code>类没有提供用于修改字符串的方法。</p><p>如果要将下面的<code>str</code>中后面的<code>&quot;key&quot;</code>修改为<code>&quot;ey!&quot;</code>，在Java中，要先提取出需要的字符，然后再拼接上替换的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;Monkey&quot;</span>;<br>str = str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) + <span class="hljs-string">&quot;ey!&quot;</span>; <span class="hljs-comment">//Money!</span><br></code></pre></td></tr></table></figure><blockquote><p>C++的字符串可以修改，即能够修改字符串中的单个字符，但Java不行。</p></blockquote><p><strong>不可变的字符串</strong>有一个优点：编译器可以让字符串<strong>共享</strong>。</p><p>字符串常量池存放在<em>方法区</em>❓，而字符串变量指向常量池中相应的位置。</p><h4 id="检测字符串是否相等："><a class="header-anchor" href="#检测字符串是否相等：">¶</a>检测字符串是否相等：</h4><p>由于<code>==</code>，对于引用类型而言，是根据<strong>地址值</strong>比较的。这个运算符只能够确定两个字符串是否放置在同一位置上。而双引号括住的字符串在常量池当中，而<code>new</code>出来的字符串不在常量池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;abc&quot;</span>;<br>String b = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">boolean</span> res = (a == b); <span class="hljs-comment">//true，因为字符串a与b为同一常量池中</span><br></code></pre></td></tr></table></figure><p>若确实需要字符串的内容进行比较可使用<code>equals</code>方法：</p><p><code>public boolean equals(Object obj);</code> ：参数可以为任何对象，但只有参数为一个字符串并且内容相同（严格区分英文大小写）的才会返回<code>true</code>，否则返回<code>false</code>。</p><p>尽管<code>equals</code>方法是可交换的（即<code>a.equals(b)</code>和<code>b.equals(a)</code>效果基本一致），但是，若要对一个常量与一个变量进行比较时，推荐常量字符串写在前面。原因见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;abc&quot;</span>.equals(str); <span class="hljs-comment">//推荐写法</span><br>str.equals(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">//不推荐写法</span><br><span class="hljs-comment">//因为，当字符串变量为null时，</span><br>String tmp = <span class="hljs-keyword">null</span>;<br>System.out.println(<span class="hljs-string">&quot;abc&quot;</span>.equals(tmp)); <span class="hljs-comment">//返回false</span><br>System.out.println(tmp.equals(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">//报错！空指针异常</span><br></code></pre></td></tr></table></figure><p>【附】：<code>int compareTo(String other)</code>：按照字典序，若字符串位于<code>other</code>之前，返回负数；若字符串位于<code>other</code>之后返回正数；若两个字符串相等，返回<code>0</code>。</p><h3 id="4-7-3-字符串相关API"><a class="header-anchor" href="#4-7-3-字符串相关API">¶</a>4.7.3 字符串相关API</h3><p>一、字符串获取：</p><ul><li><p>返回字符串的长度：<code>int length()</code></p><blockquote><p>注意，<code>String</code>类获取长度是<strong>方法</strong>，即<code>s.length()</code>；而数组的长度为<strong>成员</strong>，即<code>a.length</code>；</p></blockquote></li><li><p>获取<code>index</code>位置（从0开始）的<strong>单个字符</strong>：<code>char charAt(int index)</code></p></li><li><p>查找参数字符串<code>str</code>在本字符串当中首次出现的索引位置，若找不到则返回<code>-1</code>：<code>int indexOf(String str)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> ch = <span class="hljs-string">&quot;Hello&quot;</span>.charAt(<span class="hljs-number">1</span>); <span class="hljs-comment">//e</span><br><span class="hljs-keyword">int</span> idx = <span class="hljs-string">&quot;HelloHelloHelloHello&quot;</span>.indexOf(<span class="hljs-string">&quot;llo&quot;</span>); <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure></li></ul><p>二、字符串截取：</p><ul><li><p><code>String substring(int index)</code></p><p>截取从<code>index</code>位置（包括<code>index</code>）一直到字符串末尾的子串并将该子串返回。</p></li><li><p><code>String substring(int begin, int end)</code></p><p>从<code>begin</code>位置开始，到达不想复制的第一个位置<code>end</code>，即<code>[begin, end)</code>。显然，<code>s.substring(a, b)</code>的长度即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b -a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.77777em;vertical-align:-.08333em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String cur = <span class="hljs-string">&quot;MonkeyDLuffy&quot;</span>;<br>System.out.println(cur.substring(<span class="hljs-number">6</span>)); <span class="hljs-comment">//DLuffy</span><br>System.out.println(cur.substring(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)); <span class="hljs-comment">//key</span><br></code></pre></td></tr></table></figure></li></ul><p>三、字符串的拼接</p><p>Java语言允许使用<code>+</code>号拼接两个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;Monkey&quot;</span>;<br>str += <span class="hljs-string">&quot;Luffy&quot;</span>;<br>System.out.println(str); <span class="hljs-comment">//MonkeyLuffy</span><br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">233</span>;<br>System.out.println(<span class="hljs-string">&quot;The answer is &quot;</span> + ans); <span class="hljs-comment">//The answer is 233</span><br></code></pre></td></tr></table></figure><p>当将一个字符串与一个<strong>非字符串</strong>的值进行拼接时，后者被转换成字符串。（任何一个Java对象都可以转换成字符串）</p><p>四、字符串转换：</p><ul><li><p>将当前字符串拆分为字符数组并作为返回值：<code>char[] toCharArray</code></p></li><li><p>获得当前字符串底层的字节数组（IO流会使用）：<code>byte[] getBytes()</code></p></li><li><p>将所有出现的目标字符串<code>target</code>替换为新的字符串，返回替换之后的结果新字符串：<code>String replace(CharSequence target, CharSequence replacement)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] c = <span class="hljs-string">&quot;Hello&quot;</span>.toCharArray();<br><span class="hljs-keyword">byte</span>[] b = <span class="hljs-string">&quot;Hello&quot;</span>.getBytes();<br>String str1 = <span class="hljs-string">&quot;How do you do?&quot;</span>;<br>String str2 = str1.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>); <span class="hljs-comment">//H*w d* y*u d*?</span><br></code></pre></td></tr></table></figure></li></ul><p>五、字符串的分割：</p><ul><li><p>根据字符串<code>regex</code>，将当前字符串切分成若干子串，并返回由这些子串组成的字符串数组：<code>String[] split(String regex)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">String text = <span class="hljs-string">&quot;not to be&quot;</span>;<br>String[] words = text.split(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; words.length; i++)<br>    System.out.print(words[i]+<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">not</span><br><span class="hljs-comment">to</span><br><span class="hljs-comment">be</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：split方法的参数为正则表达式，若要按照字符’<code>.</code>'进行切分，必须写<code>\\.</code></p></blockquote></li></ul><h3 id="4-7-4-字符串转换为基本类型-与-包装类"><a class="header-anchor" href="#4-7-4-字符串转换为基本类型-与-包装类">¶</a>4.7.4 字符串转换为基本类型 与 包装类</h3><p>除了<code>Character</code>类之外，其他所有<strong>包装类都具有</strong><code>parseXxx</code>静态方法可以将<strong>字符串参数转换为对应的基本类型</strong>：</p><ul><li><p><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</p></li><li><p><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</p></li><li><p><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</p></li><li><p><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</p></li><li><p><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</p></li><li><p><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</p></li><li><p><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</p><blockquote><p>若字符串参数内容无法正确地转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote></li></ul><h2 id="4-8-StringBuilder-类"><a class="header-anchor" href="#4-8-StringBuilder-类">¶</a>4.8 StringBuilder 类</h2><p>由于<code>String</code>类的对象内容不可改变，每当进行字符串拼接时，总是需要在内存中创建一个新对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringDemo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        String s = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">//创建&quot;Hello&quot;字符串</span><br>        s += <span class="hljs-string">&quot;World!&quot;</span>; <span class="hljs-comment">//创建&quot;World!&quot;字符串，后再创建&quot;HelloWorld!&quot;</span><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要进行大量次拼接操作时，需要创建大量新的<code>String</code>对象，耗时且空间开销大，为解决此问题，可使用<code>java.lang.StringBuilder</code>类。</p><p><code>StringBuilder</code>类为<strong>可变</strong>字符序列，它类似于<code>String</code>的字符串缓冲区，内部拥有一个数组用于存放字符串内容。当进行字符串拼接时，直接在该数组中加入新内容，同时<code>StringBuilder</code>本身也会自动维护数组的扩容。</p><p>常用方法有：</p><ul><li><p><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身（源码中就是返回<code>this</code>）。</p></li><li><p><code>public String toString()</code>：将当前<code>StringBuilder</code>对象转换为不可变的<code>String</code>对象，并将该<code>String</code>对象进行返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuilder curstr = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello &quot;</span>).append(<span class="hljs-string">&quot;World&quot;</span>).append(<span class="hljs-string">&quot;!&quot;</span>);<br>        String str = curstr.toString();<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>StringBuilder</code>已经覆写了<code>Object</code>类的<code>toString</code>方法。</p></blockquote></li></ul><h2 id="4-9-大数值类"><a class="header-anchor" href="#4-9-大数值类">¶</a>4.9 大数值类</h2><p><code>java.math</code>包中有两个有用的类，可以处理包含<strong>任意长度</strong>数字序列的数值。</p><ul><li><code>BigInteger</code>：实现任意精度的整数运算。</li><li><code>BigDecimal</code>：实现任意精度的浮点数运算。</li></ul><blockquote><p>由于Java没有提供运算符重载的功能，无法重定义<code>+</code>和<code>*</code>运算符，所以<code>BigInteger</code>类运算时需用其<code>add</code>和<code>multiply</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigIntegerTest</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>, k = <span class="hljs-number">10</span>;<br>        BigInteger ans = BigInteger.valueOf(<span class="hljs-number">1</span>); <span class="hljs-comment">//大整数初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>            ans = ans.multiply(BigInteger.valueOf(n - i + <span class="hljs-number">1</span>)).divide(BigInteger.valueOf(i));<br>    &#125;<br>&#125; <span class="hljs-comment">//组合公式计算</span><br></code></pre></td></tr></table></figure><h3 id="4-9-1大数值相关API"><a class="header-anchor" href="#4-9-1大数值相关API">¶</a>4.9.1大数值相关API</h3><p>返回该大整数与另一大整数other的和、差、积、商及余数：</p><ul><li><code>BigInteger add(BigInteger other)</code></li><li><code>BigInteger substact(BigInteger other)</code></li><li><code>BigInteger multiply(BigInteger other)</code></li><li><code>BigInteger divide(BigInteger other)</code></li><li><code>BigInteger mod(BigInteger other)</code></li></ul><p>返回值等于<code>x</code>的大整数：</p><ul><li><code>static BigInteger valueOf(long x)</code></li></ul><p>若该大整数与另一个大整数other相等，返回<code>0</code>；若小于other，返回负数；否则，返回正数：</p><ul><li><code>int compareTo(BigInteger other)</code></li></ul><h2 id="4-10-数学工具类Math"><a class="header-anchor" href="#4-10-数学工具类Math">¶</a>4.10 数学工具类Math</h2><ul><li>获取绝对值，有多种重载：<code>public static double abs(double num);</code></li><li>向上取整：<code>public static double ceil(double num);</code></li><li>向下取整：<code>public static double floor(double num);</code></li><li><strong>四舍五入</strong>，返回<code>long</code>型：<code>public static long round(double num);</code></li></ul><h2 id="4-11-Object类"><a class="header-anchor" href="#4-11-Object类">¶</a>4.11 Object类</h2><p><code>java.lang.Object</code>类是Java中所有类的最终祖先，即在Java中每个类（包括数组类型）都是由它拓展而来的。</p><p>若一个类没有特别指定父类，那么默认继承自<code>Object</code>类，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> /* <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span> */</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-11-1-toString-方法"><a class="header-anchor" href="#4-11-1-toString-方法">¶</a>4.11.1 toString 方法</h3><ul><li><code>public String toString()</code> ：返回该对象的字符串表示，在<code>Object</code>类中该方法输出为：<code>对象类型@内存地址值</code>。</li></ul><blockquote><p>当我们直接使用输出语句输出对象名时，其实通过该对象调用了其<code>toString()</code>方法。</p></blockquote><p>然而在开发中需要根据对象属性得到相应的字符串表现形式，接下来便需要对该方法进行覆写。（以自定义的 <code>Person</code> 类）一般打印格式为：类的名字，随后是一对括号括起来的域值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-11-2-equals-方法"><a class="header-anchor" href="#4-11-2-equals-方法">¶</a>4.11.2 equals 方法</h3><ul><li><code>public boolean equals(Object obj)</code>：检测一个对象是否等于另一对象，在<code>Object</code>类中该方法判断两个对象是否具有相同的<strong>引用</strong>。（相当于<code>==</code>运算符的运算结果）</li></ul><p>然而，对于大多数类中，更经常地需要检测两个对象状态的相等性，比如所有成员变量相同就判定两个对象相同。因而，可以如下覆写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span></span>&#123; <span class="hljs-comment">//使用Object用于覆写超类的方法</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//getClass()返回一个对象所属的类</span><br>        Person person = (Person)o; <span class="hljs-comment">//向下转型，以使用子类特有的成员。</span><br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp; Object.equals(name, person.name);<br>        <span class="hljs-comment">//基本类型相等，且将引用类型交给java.util.Objects类的equals静态方法取用结果。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TIPS：IDEA中的“代码”（Code）菜单——“生成”（Generate）可以快速生成上面的<code>toString</code>方法和<code>equals</code>方法的覆写。</p></blockquote><h3 id="4-11-3-Objects-工具类"><a class="header-anchor" href="#4-11-3-Objects-工具类">¶</a>4.11.3 Objects 工具类</h3><p>JDK7添加<code>Objects</code>工具类（注意，不是<code>Object</code>类），它由一些静态的实用方法组成，分为<em>null-save</em>（空指针安全）和<em>null-tolerant</em>（容忍空指针），用于计算对象的<code>hashcode</code>、返回对象的字符串表现形式、比较两个对象。</p><ul><li><p><code>public static boolean equals(Object a, Object b)</code>：判断两个对象的<strong>内容</strong>是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>public static &lt;T&gt; T requireNonNull(T obj)</code> ：判断传入的引用对象是否为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        <span class="hljs-comment">//Objects.requireNonNull(obj);</span><br>        Objects.requireNonNull(obj, <span class="hljs-string">&quot;传递的对象为null!&quot;</span>);<br>    &#125; <span class="hljs-comment">//对传递过来的参数进行合法性判断，判断是否为null</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-12-日期时间类"><a class="header-anchor" href="#4-12-日期时间类">¶</a>4.12 日期时间类</h2><h3 id="4-12-1-Date-类"><a class="header-anchor" href="#4-12-1-Date-类">¶</a>4.12.1 Date 类</h3><p><code>java.util.Date</code>类 的实例有一个状态，即特定的时间点。这个时间 是 用距离一个固定时间点的毫秒数（可正可负），而这个固定时间点为纪元(<em>epoch</em>)——UTC 时间 1971 年 1 月 1 日 00 : 00 : 00 。</p><blockquote><p>由于我们身处东八区，则基准时间为1970年1月1日8时0分0秒</p></blockquote><blockquote><p>用类描述时间的好处在于，若类的设计不够完善，则可以编写自己的类以便增强或替代系统提供的类</p></blockquote><p>构造方法：</p><ul><li><p><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒），自动设置当前系统时间的毫秒时刻；</p></li><li><p><code>public Date(long date)</code>：分配Date对象并初始化此对象以表示自从<em>纪元</em>以来的指定毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> Date());<br>        <span class="hljs-comment">//Thu Oct 29 21:03:14 CST 2020</span><br>        System.out.println(<span class="hljs-keyword">new</span> Date(<span class="hljs-number">0L</span>)); <span class="hljs-comment">//将毫秒值转成日期对象</span><br>        <span class="hljs-comment">//Thu Jan 01 08:00:00 CST 1970</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-12-2-DateFormat-类"><a class="header-anchor" href="#4-12-2-DateFormat-类">¶</a>4.12.2 DateFormat 类</h3><p><code>java.text.DateFormat</code> 为日期/时间格式化子类的<strong>抽象类</strong>，通过该类可以实现日期与文本间的转换（即Date对象与String对象间转换）</p><ul><li><strong>格式化</strong>：按指定格式，Date对象 -&gt; String对象。</li><li><strong>解析</strong>：按指定格式，String对象 -&gt; Date对象。</li></ul><p>一、构造方法</p><p>由于<code>DateFormat</code>为<strong>抽象类</strong>，需要常用的子类<code>java.text.SimpleDateFormat</code>（需要一个模式/格式来指定格式化或解析的标准），构造方法为：</p><ul><li><p><code>public SimpleDateFormat(String pattern)</code>：用给定模式和默认语言环境的日期格式符号构造<code>SimpleDateFormat</code>。其中<code>pattern</code>为 代表日期时间的自定义格式 的字符串。</p></li><li><p>格式规则</p><table><thead><tr><th style="text-align:center">标识字母（区分大小写）</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">年</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">月</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">日</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">时</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">分</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">秒</td></tr></tbody></table></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DateFormat format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-comment">//对应日期格式为：2020-10-29 21:33:11</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>二、常用方法</p><ul><li><p><code>public String format(Date date)</code>：将Date对象格式化为字符串；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Date date = <span class="hljs-keyword">new</span> Date();<br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>); <span class="hljs-comment">//创建日期格式化对象，指定风格</span><br>        String str = df.format(date);<br>        System.out.println(str); <span class="hljs-comment">//2020年10月29日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>public Date parse(String source)</code>：将字符串解析为Date对象；</p><blockquote><p>注意，该方法需要对异常进行处理！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.ParseException; <span class="hljs-comment">//导包</span><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123; <span class="hljs-comment">//异常处理</span><br>        DateFormat df = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>); <span class="hljs-comment">//创建日期格式化对象，指定风格</span><br>        String str = <span class="hljs-string">&quot;2001年1月7日&quot;</span>;<br>        Date bir = df.parse(str);<br>        System.out.println(bir); <span class="hljs-comment">//2020年10月29日</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>public long getTime()</code>：将日期对象转换成对应的时间毫秒值。（可能已过时，但在计算某些时间差值时比较有用）</p></li></ul><p>计算一个人从出生到此刻的天数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;请按YYYY年MM月dd日的格式输入您的出生日期：&quot;</span>);<br>        String birStr = <span class="hljs-keyword">new</span> Scanner(System.in).next(); <span class="hljs-comment">//输入字符串日期</span><br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>); <span class="hljs-comment">//指定日期模式</span><br>        Date birDate = sdf.parse(birStr); <span class="hljs-comment">//调用parse方法将输入的字符串转换为日期对象</span><br>        <span class="hljs-keyword">long</span> birSec = birDate.getTime(); <span class="hljs-comment">//返回该日期的毫秒时刻</span><br><br>        Date curDate = <span class="hljs-keyword">new</span> Date(); <span class="hljs-comment">//获取此时此刻的日期</span><br>        <span class="hljs-keyword">long</span> curSec = curDate.getTime();<br><br>        <span class="hljs-keyword">long</span> diff = curSec - birSec; <span class="hljs-comment">//计算差值</span><br>        <span class="hljs-keyword">if</span>(diff &lt; <span class="hljs-number">0</span>) System.out.println(<span class="hljs-string">&quot;还没出生呢!&quot;</span>);<br>        <span class="hljs-keyword">else</span> System.out.println(diff/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span>/<span class="hljs-number">60</span>/<span class="hljs-number">24</span>); <span class="hljs-comment">//毫秒转换为天</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-13-Calendar-类"><a class="header-anchor" href="#4-13-Calendar-类">¶</a>4.13 Calendar 类</h2><p><code>java.util.Calendar</code>为日历类，该类将所有可能用到的时间信息封装为静态成员变量以便获取。</p><blockquote><p><code>Calendar</code>类中的方法取代了许多<code>Date</code>的方法。</p></blockquote><p>一、创建对象</p><p>由于<code>Calendar</code>类为<strong>抽象类</strong>，它不能够直接创建，而是通过静态方法返回一个子类对象来进行创建（多态），该静态方法为：</p><ul><li><p><code>public static Calendar getInstance()</code>：使用默认时区与语言环境获得一个 日历 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance();<br></code></pre></td></tr></table></figure></li></ul><p>二、常用方法</p><p><code>Calendar</code>类中提供很多有关日历的成员常量，它们各自代表不同的日历字段，同时也对应于<code>Calendar</code>相关方法中的传入参数<code>field</code>。</p><table><thead><tr><th style="text-align:center">字段值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">YEAR</td><td style="text-align:center">年</td></tr><tr><td style="text-align:center">MONTH</td><td style="text-align:center">月（从0开始，可以+1使用）</td></tr><tr><td style="text-align:center">DAY_OF_MONTH</td><td style="text-align:center">月中的天（几号）</td></tr><tr><td style="text-align:center">HOUR</td><td style="text-align:center">时（12小时制）</td></tr><tr><td style="text-align:center">HOUR_OF_DAY</td><td style="text-align:center">时（24小时制）</td></tr><tr><td style="text-align:center">MINUTE</td><td style="text-align:center">分</td></tr><tr><td style="text-align:center">SECOND</td><td style="text-align:center">秒</td></tr><tr><td style="text-align:center">DAY_OF_WEEK</td><td style="text-align:center">周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><blockquote><p><code>Calendar.YEAR</code>存的值为<code>3</code>，并不代表它就是记录月份，而是用于方法中识别的。其他成员常量也同理。</p></blockquote><blockquote><p>西方星期开始为周日，月份表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>−</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">0-11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">11</span></span></span></span>。</p></blockquote><p>根据<code>Calendar</code>类的API文档，常用方法有：</p><ul><li><p><code>public int get(int field)</code>：给定日历字段<code>field</code>，让其返回该字段含义的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance();<br><span class="hljs-keyword">int</span> curyear = cal.get(Calendar.YEAR); <br><span class="hljs-comment">//我传入一个参数Calendar.YEAR，方法get()就会知道我要查询当前年份的值</span><br></code></pre></td></tr></table></figure></li><li><p><code>public void set(int field, int value)</code>：给定日历字段<code>field</code>，要其字段对应含义的值修改为<code>value</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance();<br>cal.set(Calendar.YEAR, <span class="hljs-number">2020</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>public abstract void add(int field, int amount)</code>：根据日历规则，为给定的日历字段添加或减去指定的时间量<code>amount</code>。若<code>amount</code>为负数，则说明减去偏移量；反之，为加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance(); <span class="hljs-comment">//2020年10月30日</span><br>cal.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">2</span>); <span class="hljs-comment">//加2天</span><br>cal.add(Calendar.MONTH, -<span class="hljs-number">3</span>); <span class="hljs-comment">//减三个月</span><br><span class="hljs-keyword">int</span> mon = cal.get(Calendar.MONTH);<br><span class="hljs-keyword">int</span> day = cal.get(Calendar.DAY_OF_MONTH);<br>System.out.println(mon+<span class="hljs-string">&quot;月&quot;</span>+day+<span class="hljs-string">&quot;日&quot;</span>); <span class="hljs-comment">//7月1日</span><br></code></pre></td></tr></table></figure></li><li><p><code>public Date getTime()</code>：返回一个表示此<code>Calendar</code>时间值（从 <em>纪元</em> 到现在的毫秒数）的<code>Date</code>对象。（不同于<code>Date</code>类的<code>getTime()</code>方法！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance();<br>Date date = cal.getTime();<span class="hljs-comment">//Fri Oct 30 00:40:00 CST 2020</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="4-14-System-类"><a class="header-anchor" href="#4-14-System-类">¶</a>4.14 System 类</h2><p><code>java.lang.System</code> 类中提供大量静态方法，可获取与系统相关的信息或系统级操作。常用方法有：</p><ul><li><p><code>public static long currentTimeMillis()</code>：获取当前系统时间与 1970 年 01 月 01 日 00:00 点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JustTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> st = currentTimeMillis();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++)&#123;&#125;<br>        <span class="hljs-keyword">long</span> ed = currentTimeMillis();<br>        <span class="hljs-keyword">long</span> diff = ed - st;<br>        System.out.println(diff); <span class="hljs-comment">//4ms.........</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</p></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Joy Dee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.joydee.top/posts/548f7542/">https://www.joydee.top/posts/548f7542/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.joydee.top" target="_blank">JoyDee's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 不妨请我一杯咖啡？</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.joydee.cloud/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4775c8be/"><img class="prev-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「JavaSE学习笔记03」继承、接口、多态、内部类</div></div></a></div><div class="next-post pull-right"><a href="/posts/443edace/"><img class="next-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「JavaSE学习笔记01」开发前言与环境搭建、基础语法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/a0f59037/" title="「JavaSE学习笔记04」异常"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-31</div><div class="title">「JavaSE学习笔记04」异常</div></div></a></div><div><a href="/posts/c11c98d4/" title="「JavaSE学习笔记06」并发"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-12</div><div class="title">「JavaSE学习笔记06」并发</div></div></a></div><div><a href="/posts/4775c8be/" title="「JavaSE学习笔记03」继承、接口、多态、内部类"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-25</div><div class="title">「JavaSE学习笔记03」继承、接口、多态、内部类</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/avatar.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Joy Dee</div><div class="author-info__description">Cause I have a dream.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">112</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/J-StrawHat"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/J-StrawHat" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:422148166@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/j_strawhat-2/" target="_blank" title="LeetCode"><i class="fas fa-code"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-box-open"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-text">Chapter 4. 对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1 面向对象程序设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%B1%BB"><span class="toc-text">4.1.1 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.1.2 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">4.2 对象与类的相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">4.2.1 最简单的类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%A0%87%E5%87%86%E7%B1%BB%EF%BC%88Java-Bean%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">4.2.2 标准类（Java Bean）的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.3 对象的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2.4 对象的创建与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84-%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-text">[附]几个对象的内存图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.2.5 匿名对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-%E9%9D%99%E6%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">4.2.6 静态static关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%B0%81%E8%A3%85"><span class="toc-text">4.3 封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-this"><span class="toc-text">4.3.1 this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Scanner%E7%B1%BB"><span class="toc-text">4.4 Scanner类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">4.4.1 引用类型的使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.4.2 概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Random%E7%B1%BB"><span class="toc-text">4.5 Random类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%EF%BC%9AArrayList%E9%9B%86%E5%90%88"><span class="toc-text">4.6 泛型数组列表：ArrayList集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E5%BC%95%E5%85%A5%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">4.6.1 引入——对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.6.2 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-text">4.6.3 数组列表的相关操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-4-%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE-%E4%B8%8E-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">4.6.4 数组列表存储基本类型数据 与 包装类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-String%E7%B1%BB"><span class="toc-text">4.7 String类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA"><span class="toc-text">4.7.1 字符串的构造方法和直接创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E6%A3%80%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-text">4.7.2 字符串常量池、检测字符串是否相等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9A"><span class="toc-text">检测字符串是否相等：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3API"><span class="toc-text">4.7.3 字符串相关API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-%E4%B8%8E-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">4.7.4 字符串转换为基本类型 与 包装类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-StringBuilder-%E7%B1%BB"><span class="toc-text">4.8 StringBuilder 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E5%A4%A7%E6%95%B0%E5%80%BC%E7%B1%BB"><span class="toc-text">4.9 大数值类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1%E5%A4%A7%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3API"><span class="toc-text">4.9.1大数值相关API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E7%B1%BBMath"><span class="toc-text">4.10 数学工具类Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-Object%E7%B1%BB"><span class="toc-text">4.11 Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-1-toString-%E6%96%B9%E6%B3%95"><span class="toc-text">4.11.1 toString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-2-equals-%E6%96%B9%E6%B3%95"><span class="toc-text">4.11.2 equals 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-3-Objects-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">4.11.3 Objects 工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-text">4.12 日期时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-1-Date-%E7%B1%BB"><span class="toc-text">4.12.1 Date 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-2-DateFormat-%E7%B1%BB"><span class="toc-text">4.12.2 DateFormat 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-Calendar-%E7%B1%BB"><span class="toc-text">4.13 Calendar 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-System-%E7%B1%BB"><span class="toc-text">4.14 System 类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-car"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/9e115195/" title="计算机网络错题汇总"><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/jisuanjiwangluo.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络错题汇总"></a><div class="content"><a class="title" href="/posts/9e115195/" title="计算机网络错题汇总">计算机网络错题汇总</a><time datetime="2021-06-18T13:00:00.000Z" title="发表于 2021-06-18 21:00:00">2021-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/67a91b71/" title="「数电实验课程设计4」可控进制的计数器"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「数电实验课程设计4」可控进制的计数器"></a><div class="content"><a class="title" href="/posts/67a91b71/" title="「数电实验课程设计4」可控进制的计数器">「数电实验课程设计4」可控进制的计数器</a><time datetime="2021-06-16T16:57:53.000Z" title="发表于 2021-06-17 00:57:53">2021-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/290ad7f9/" title="马原考点总结"><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/marxismbanner.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="马原考点总结"></a><div class="content"><a class="title" href="/posts/290ad7f9/" title="马原考点总结">马原考点总结</a><time datetime="2021-06-13T09:00:00.000Z" title="发表于 2021-06-13 17:00:00">2021-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/da2a8f19/" title="「数据库系统概论」问答题总结"><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/shujukuxitonggailun.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「数据库系统概论」问答题总结"></a><div class="content"><a class="title" href="/posts/da2a8f19/" title="「数据库系统概论」问答题总结">「数据库系统概论」问答题总结</a><time datetime="2021-06-10T11:47:53.000Z" title="发表于 2021-06-10 19:47:53">2021-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/83a0adbc/" title="「JavaSE学习笔记10」Java 易错归纳"><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="「JavaSE学习笔记10」Java 易错归纳"></a><div class="content"><a class="title" href="/posts/83a0adbc/" title="「JavaSE学习笔记10」Java 易错归纳">「JavaSE学习笔记10」Java 易错归纳</a><time datetime="2021-06-06T05:04:00.000Z" title="发表于 2021-06-06 13:04:00">2021-06-06</time></div></div></div></div></div></div></main><footer id="footer" style="background:#393d49"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Joy Dee</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you learn something in my blog and leave your comment!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论区"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>(()=>{const t=document.getElementById("twikoo-count"),e=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-comment.vercel.app/",region:"",katex:{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1}},null))},o=()=>{twikoo.getCommentsCount({envId:"https://twikoo-comment.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(e){t.innerText=e[0].count})).catch((function(t){console.error(t)}))},i=(i=!1)=>{"object"==typeof twikoo?(e(),i&&t&&setTimeout(o,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{e(),i&&t&&setTimeout(o,0)})};i(!0)})()</script></div><script src="https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script></div></body></html>