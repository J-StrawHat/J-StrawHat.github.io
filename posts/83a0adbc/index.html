<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>「JavaSE学习笔记10」Java 易错归纳 | JoyDee's Blog</title><meta name="keywords" content="JavaSE"><meta name="author" content="Joy Dee"><meta name="copyright" content="Joy Dee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="¶Chapter 1 概述 ¶Java跨平台 Java 既具有解释型语言的特征，也具有编译型语言的特征。  Java既不是编译型语言也不是解释型语言，还是静态语言。  Java语言经过编译器编译后生成与平台无关的字节码文件（*.class，需要由Java解释器来解释执行）  不同操作系统有不同的虚拟机，但提供一个相同的面向编译器的接口。 只要为不同平台实现了相应的虚拟机，编译之后的Java字节码就"><meta property="og:type" content="article"><meta property="og:title" content="「JavaSE学习笔记10」Java 易错归纳"><meta property="og:url" content="https://www.joydee.top/posts/83a0adbc/index.html"><meta property="og:site_name" content="JoyDee&#39;s Blog"><meta property="og:description" content="¶Chapter 1 概述 ¶Java跨平台 Java 既具有解释型语言的特征，也具有编译型语言的特征。  Java既不是编译型语言也不是解释型语言，还是静态语言。  Java语言经过编译器编译后生成与平台无关的字节码文件（*.class，需要由Java解释器来解释执行）  不同操作系统有不同的虚拟机，但提供一个相同的面向编译器的接口。 只要为不同平台实现了相应的虚拟机，编译之后的Java字节码就"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif"><meta property="article:published_time" content="2021-06-06T05:04:00.000Z"><meta property="article:modified_time" content="2021-12-18T02:29:53.917Z"><meta property="article:author" content="Joy Dee"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.joydee.top/posts/83a0adbc/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><meta name="google-site-verification" content="FcqPwEYbr_cknqo4XYD1DIbaczUgJwPf9WVNALOG_rA"><meta name="baidu-site-verification" content="code-BTKhd4k3xT"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3c4988fb9892b3bebf918781af0b8ace";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-184747878-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-184747878-1")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:700},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: Joy Dee",link:"链接: ",source:"来源: JoyDee's Blog",info:"本文为作者的原创文章。遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#0483fa",bgDark:"#00c4b6",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"「JavaSE学习笔记10」Java 易错归纳",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-18 10:29:53"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};n(),document.addEventListener("pjax:complete",n)})(window)</script><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="/css/joydee.css"><link rel="stylesheet" href="/css/night-owl.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@latest/pace-theme-default.min.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JoyDee's Blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/avatar.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">129</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-layer-group"></i> <span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-shapes"></i> <span>文章分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i> <span>时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tag"></i> <span>标签云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-user-graduate"></i> <span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://music.apple.com/cn/browse"><i class="fa-fw fas fa-music"></i> <span>AppleMusic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://portal.qiniu.com/home"><i class="fa-fw fas fa-images"></i> <span>七牛云图床</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i> <span>关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JoyDee's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-layer-group"></i> <span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-shapes"></i> <span>文章分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw far fa-calendar-alt"></i> <span>时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tag"></i> <span>标签云</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-user-graduate"></i> <span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://music.apple.com/cn/browse"><i class="fa-fw fas fa-music"></i> <span>AppleMusic</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://portal.qiniu.com/home"><i class="fa-fw fas fa-images"></i> <span>七牛云图床</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user-circle"></i> <span>关于我</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="coverdiv"><img id="post-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"></div><div id="post-info"><div id="post-categories-container"><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/JavaSE/">JavaSE</a></span></div><h1 class="post-title">「JavaSE学习笔记10」Java 易错归纳</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-06T05:04:00.000Z" title="发表于 2021-06-06 13:04:00">2021-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-18T02:29:53.917Z" title="更新于 2021-12-18 10:29:53">2021-12-18</time></span><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="fas fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span></span><span class="post-meta-separator">|</span><span data-flag-title="「JavaSE学习笔记10」Java 易错归纳"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="fas fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/83a0adbc/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-1-概述"><a class="header-anchor" href="#Chapter-1-概述">¶</a>Chapter 1 概述</h1><h2 id="Java跨平台"><a class="header-anchor" href="#Java跨平台">¶</a>Java跨平台</h2><p>Java 既具有解释型语言的特征，也具有编译型语言的特征。</p><blockquote><p>Java既不是编译型语言也不是解释型语言，还是静态语言。</p></blockquote><p>Java语言经过编译器编译后生成<strong>与平台无关</strong>的字节码文件（<code>*.class</code>，需要由Java解释器来解释执行）</p><blockquote><p>不同操作系统有不同的虚拟机，但提供一个相同的面向编译器的接口。</p><p>只要为不同平台实现了相应的虚拟机，编译之后的Java字节码就可以在该平台上运行</p></blockquote><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621203334.png" style="zoom:67%"> <img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621203617.png" style="zoom:67%"><h2 id="编译与运行Java源文件"><a class="header-anchor" href="#编译与运行Java源文件">¶</a>编译与运行Java源文件</h2><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621203804.png" style="zoom:67%"><p>举例如下：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621204554.png" style="zoom:67%"><p><code>java</code>命令运行文件，紧跟于java文件中的类名，如<code>java HelloWorld</code>（注意，<code>java</code>命令针对于 <code>class</code> 文件，但是在输入命令时不加<code>.class</code>后缀）</p><h2 id="main方法"><a class="header-anchor" href="#main方法">¶</a>main方法</h2><p>签名：<code>public static void main(String[] arg)</code></p><p>其中，<code>public</code> 与 <code>static</code> 前后顺序可互换，但 <code>public</code> 可以省略不写，<code>static</code> 必须要使用</p><p>另外，返回值只能是 <code>void</code> ，否则该方法不是程序的入口方法</p><blockquote><p>若写成 <code>Main</code> 方法，Java解释器无法找到 <code>main</code> 方法</p></blockquote><h2 id="Java源文件"><a class="header-anchor" href="#Java源文件">¶</a>Java源文件</h2><ul><li><p>一个Java文件只能有一个 <code>public</code> 类，且文件名必须与 <code>public</code> 类名一致</p></li><li><p>注意，每个源文件最多只有一个包声明，必须位于 Java 源文件的第一行</p></li><li><p>Java程序中所有的关键字都是小写，无须任何大写字母</p></li></ul><h2 id="编程错误"><a class="header-anchor" href="#编程错误">¶</a>编程错误</h2><ul><li>语法错误</li><li>运行错误</li><li>逻辑错误</li></ul><h1 id="Chapter-2"><a class="header-anchor" href="#Chapter-2">¶</a>Chapter 2</h1><h2 id="Java标识符"><a class="header-anchor" href="#Java标识符">¶</a>Java标识符</h2><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621220122.png" style="zoom:67%"><p>所有<strong>关键字</strong>都是由小写英文字母组成的</p><h2 id="基本数据类型"><a class="header-anchor" href="#基本数据类型">¶</a>基本数据类型</h2><ul><li><p><code>true</code> 和 <code>false</code> 只能小写</p></li><li><p>⭐<strong>表达式类型的自动提升</strong>：一个算术表达式包含多个基本类型的值时，整个算术表达式的数据类型都将发生自动提升，规则如下：</p><ul><li>所有 <code>byte</code>、<code>short</code>、<code>char</code> 类型自动提升到 <code>int</code></li><li>自动提升到表达式中最高等级操作同样的类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> b = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">23</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.5</span>;<br><span class="hljs-keyword">double</span> res = b + c + i * d;<br><span class="hljs-comment">//最高级操作数d是double，右边所有变量类型自动提升到double，结果自然是double</span><br><br><span class="hljs-keyword">short</span> s = <span class="hljs-number">5</span>;<br>s = s - <span class="hljs-number">2</span>; <span class="hljs-comment">//编译错误。右式自动提升到int，赋值时需强转</span><br></code></pre></td></tr></table></figure></li><li><p>一个值赋给范围更小类型的，必须强制转换（然而，会有进度降低或溢出）</p></li></ul><h2 id="Scanner"><a class="header-anchor" href="#Scanner">¶</a>Scanner</h2><p>从控制台中读取字符串：<code>next()</code> 读取以<strong>空白字符</strong>结束的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>String s = sc.next();<br></code></pre></td></tr></table></figure><h2 id="字符编码"><a class="header-anchor" href="#字符编码">¶</a>字符编码</h2><p>四种等价赋值方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;\u0061&#x27;</span>; <span class="hljs-comment">// &#x27;\uXXXX&#x27;中&#x27;XXXX&#x27;代表一个十六进制的整数</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-number">0x0061</span>;<br><span class="hljs-keyword">char</span> c = <span class="hljs-number">97</span>;<br></code></pre></td></tr></table></figure><h2 id="字符型与数值型数据的转换"><a class="header-anchor" href="#字符型与数值型数据的转换">¶</a>字符型与数值型数据的转换</h2><p>当一个整数转换成 <code>char</code> 型数据时，只使用整数的低十六位，其他部分忽略，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> c = (<span class="hljs-keyword">char</span>)<span class="hljs-number">0xAB0041</span>; <span class="hljs-comment">//取最后0x41，得到&#x27;A&#x27;</span><br></code></pre></td></tr></table></figure><p>若操作数是一个数字或字符，<code>char</code> 自动转换为数字，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;2&#x27;</span> + <span class="hljs-string">&#x27;3&#x27;</span>; <span class="hljs-comment">//&#x27;e&#x27;</span><br><span class="hljs-keyword">int</span> x = <span class="hljs-string">&#x27;2&#x27;</span> + <span class="hljs-string">&#x27;3&#x27;</span>; <span class="hljs-comment">//101</span><br><span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">//99</span><br><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&quot;d&quot;</span>; <span class="hljs-comment">//显然是错误的!!!</span><br></code></pre></td></tr></table></figure><p>对于字符串：</p><ul><li><p>对于<code>+</code>运算符，若操作数之一不是字符串，则非字符串自动转换为字符串，注意下方坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;1+2=&quot;</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2</span>); <span class="hljs-comment">//12</span><br>System.out.println(<span class="hljs-string">&quot;1+2=&quot;</span>+(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>)); <span class="hljs-comment">//3</span><br><br>System.out.println(<span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">//11</span><br>System.out.println(<span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">//50，&#x27;1&#x27;自动转换为数字</span><br></code></pre></td></tr></table></figure><p>由此，数字转换成字符串的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = number + <span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>字符串转换成数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> val = Double.parseDouble(<span class="hljs-string">&quot;23.3&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h1 id="Chapter-3-5-流程控制"><a class="header-anchor" href="#Chapter-3-5-流程控制">¶</a>Chapter 3+5 流程控制</h1><h2 id="switch-语句"><a class="header-anchor" href="#switch-语句">¶</a>switch 语句</h2><ul><li><p>对于 <code>switch(expr)</code> 语句，其 <code>expr</code> 表达式类型应与 <code>int</code> 类型兼容：<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code> ，又或者是字符串，又或者是枚举类型</p><blockquote><p>注意，<code>long</code> 类型以及浮点类型，均不能够自动地转换为 <code>int</code> 类型</p></blockquote></li><li><p>对于 <code>case valueN</code> 子句中，<code>valueN</code> 必须是常量</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621180653.png" style="zoom:67%"></li></ul><h2 id="random-方法"><a class="header-anchor" href="#random-方法">¶</a>random 方法</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>M</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mn>1.0</mn></mrow><annotation encoding="application/x-tex">0 \le Math.random() &lt; 1.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.10903em">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1.0</span></span></span></span> 故：</p><ul><li>返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[a, a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>：<code>a + Math.random() * b</code></li><li>返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[10, 20)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">10</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">20</span><span class="mclose">)</span></span></span></span>：<code>(int)(10 + Math.random()*10)</code></li><li>随机返回 0 或 1：<code>(int)(Math.random()*10)%2</code></li></ul><h1 id="Chapter-6-方法"><a class="header-anchor" href="#Chapter-6-方法">¶</a>Chapter 6. 方法</h1><h2 id="方法签名"><a class="header-anchor" href="#方法签名">¶</a>方法签名</h2><p><strong>方法名+参数列表</strong></p><h2 id="方法的重载"><a class="header-anchor" href="#方法的重载">¶</a>方法的重载</h2><p>方法的重载与方法返回值类型、修饰符等没有任何关系。</p><p>因此，被重载的方法必须具有<strong>不同的参数列表</strong>，不能基于不同的修饰符或返回值类型（否则编译错误）</p><p>关于方法的匹配，你</p><h2 id="static修饰符"><a class="header-anchor" href="#static修饰符">¶</a>static修饰符</h2><p>静态方法不能够直接调用非静态成员变量和非静态方法，经典错误如下：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621162853.png" style="zoom:67%"><h2 id="方法体"><a class="header-anchor" href="#方法体">¶</a>方法体</h2><ul><li><p>对于有返回值的方法，<code>return</code> 语句必需的，尽管代码逻辑正确，但编译器并不认为是正确的（编译错误）</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621164102.png" style="zoom:67%"></li><li><p>对变量初始化时，注意下面的坑点：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621164447.png" style="zoom:67%"></li></ul><h2 id="方法调用"><a class="header-anchor" href="#方法调用">¶</a>方法调用</h2><p>一个方法结束运行会返回调用者，同时其活动记录中所有变量会从栈中移出（释放所有变量），定义在方法中的变量（包括引用类型）也结束其声明周期</p><h2 id="方法中参数传递"><a class="header-anchor" href="#方法中参数传递">¶</a>方法中参数传递</h2><ul><li>一个方法不能修改一个基本数据类型的参数</li><li>一个方法可改变一个对象参数的状态</li><li>一个方法不能够让对象参数引用一个新的对象</li></ul><h1 id="Chapter-7-一维数组"><a class="header-anchor" href="#Chapter-7-一维数组">¶</a>Chapter 7. 一维数组</h1><h2 id="数组的初始化"><a class="header-anchor" href="#数组的初始化">¶</a>数组的初始化</h2><blockquote><p>实际数组元素被存储在堆heap内存中，数组引用变量是引用类型变量，被存储在栈内存中</p></blockquote><ul><li><p>静态初始化：开发人员显式地指定每个数组元素的<strong>初始值</strong>，系统决定长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//注意不要漏了中括号</span><br><span class="hljs-keyword">int</span> <br><span class="hljs-keyword">float</span>[] f = &#123;<span class="hljs-number">1.2f</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4f</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">//注意坑点</span><br></code></pre></td></tr></table></figure></li><li><p>动态初始化：开发人员只指定数组长度，系统为数组分配初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] mylist; <span class="hljs-comment">//声明整形的数组</span><br>mylist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">//创建数组并将数组的引用赋值给mylist</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：不能同时使用静态初始化和动态初始化</p></blockquote></li></ul><h2 id="数组的长度"><a class="header-anchor" href="#数组的长度">¶</a>数组的长度</h2><p>注意普通数组的长度为：<code>arr.length</code>；而 <code>String</code> 的长度为：<code>arr.length()</code>，此外：<code>&quot;Hello&quot;.length()</code></p><h2 id="数组的复制"><a class="header-anchor" href="#数组的复制">¶</a>数组的复制</h2><ol><li><p>循环语句遍历赋值</p></li><li><p>使用 <code>System</code> 类中的静态方法 <code>arraycopy()</code>：内容相同，引用不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] list = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] list2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>System.arraycopy(list, <span class="hljs-number">2</span>, list2, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>clone</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] list = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span>[] list2 = list.clone();<br></code></pre></td></tr></table></figure></li></ol><h2 id="可变长参数列表"><a class="header-anchor" href="#可变长参数列表">¶</a>可变长参数列表</h2><p><code>...</code> 来表示数组可变参数，参数数目不确定但类型确定的情况。</p><p>如果方法中有多个类型参数，可变长参数必须是最后一个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wtf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> opt, <span class="hljs-keyword">int</span>...arr)</span></span>&#123;<br>    System.out.println(arr.length);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Arrays-工具类"><a class="header-anchor" href="#Arrays-工具类">¶</a>Arrays 工具类</h2><p>它包含了大量静态方法，常用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br>Arrays.sort(arr);<br>System.out.println(Arrays.toString(arr));<br></code></pre></td></tr></table></figure><h2 id="命令行参数"><a class="header-anchor" href="#命令行参数">¶</a>命令行参数</h2><p>在命令行通过给 <code>main</code> 方法传递参数 <code>String[] args</code> ，其中参数均为字符串，但不一定需要用 <code>&quot;&quot;</code> 引起来</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621160931.png"><p>默认情况下（命令行中不传递参数），<code>args</code> 参数长度为 0 的空数组（并非 <code>null</code>）</p><h1 id="Chapter9-对象和类"><a class="header-anchor" href="#Chapter9-对象和类">¶</a>Chapter9. 对象和类</h1><ul><li><p>对象通过引用变量访问，该变量包含对象的<strong>引用地址</strong></p><blockquote><p>也就说，对象引用变量实际上只包含了对象的引用地址，并不是存放了一个对象</p></blockquote><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210606215554.png" style="zoom:50%"> <img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210606215754.png" style="zoom:67%"><blockquote><p><code>System.arraycopy()</code> 方法是 <code>native</code> 方法，性能优于普通方法</p></blockquote></li><li><p>只有当类中<strong>无明确声明</strong>构造方法时，才会自动生成默认无参构造方法。</p><blockquote><p>也就说，类若提供了有参构造方法，但没有提供无参构造方法时，调用有参的构造方法合法，但调用无参的构造方法，会编译错误！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;233&quot;</span>);<br>    &#125;<br>    Test(<span class="hljs-keyword">int</span> i)&#123;<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test a = <span class="hljs-keyword">new</span> Test(); <span class="hljs-comment">//编译错误!因为无参构造方法没有自动生成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个类里可包含多个初始化块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    &#123; <span class="hljs-comment">//第二个执行（每创建一个对象，就）</span><br>        System.out.println(<span class="hljs-string">&quot;init-block&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">//第一个执行（每个类只执行一次）</span><br>        System.out.println(<span class="hljs-string">&quot;static&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//第三个执行</span><br>        System.out.println(<span class="hljs-string">&quot;WTFFFF&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>关于日期类 <code>Calender</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">GregorianCalendar cal = <span class="hljs-keyword">new</span> GregorianCalendar();<br>System.out.println(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss EEEE&quot;</span>).format(cal.getTime()));<br><span class="hljs-comment">//2021-06-06 10:17:45 星期日</span><br></code></pre></td></tr></table></figure><p>此处有个小坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Date d = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">12346788765</span>); <span class="hljs-comment">//编译错误，Integer number too large</span><br>Date d = <span class="hljs-keyword">new</span> <br></code></pre></td></tr></table></figure></li><li><p>关于 <code>Random</code> 类：</p><blockquote><p>java.utl 包含 <code>Date</code>、<code>Random</code>。而 java.lang 包含 <code>System</code>、<code>Math</code></p></blockquote><ul><li><p>有参构造方法的参数类型是 <code>long</code>，故：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Random g = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">3.4</span>); <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure></li><li><p>返回的值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p></li><li><p>若两个<code>Random</code> 对象有相同的种子，那它们将产生相同的数列。</p><blockquote><p>因为其无参构造方法使用当前时间已经逝去的时间作为种子</p></blockquote></li></ul></li><li><p>Java 垃圾回收的工作原理：</p><ul><li><p>若一个对象被赋为<strong>空引用</strong>或没有使用，就成为 <code>garbage</code> 回收的候选者；如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;good&quot;</span>);<br>s1 = s2; <span class="hljs-comment">//此时字符串对象&quot;hello&quot;符合垃圾收集条件</span><br>String sb = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;WTF&quot;</span>);<br>sb = <span class="hljs-keyword">null</span>; <span class="hljs-comment">//此时&quot;WTF&quot;对象会因符合垃圾收集条件而被销毁</span><br></code></pre></td></tr></table></figure><blockquote><p>准确地来说，当没有任何活的线程<strong>能够访问</strong>一个对象时，该对象就<strong>符合垃圾收集条件</strong>。凭借此，程序员可以指定垃圾回收器回收对象。</p></blockquote></li><li><p>垃圾回收程序并<strong>不会马上</strong>回收该对象，而是在 JVM 探测出应用程序的内存不足的时候，或者是在 JVM 闲置时才进行回收；</p><blockquote><p>垃圾回收器<strong>不能保证有足够的的内存</strong>（无法保证 Java 程序从不产生内存溢出），它只能保证可用内存尽可能得到高效管理。</p></blockquote></li></ul><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210606221202.png" style="zoom:67%"></li><li><p>你无法强迫垃圾回收器立即执行回收动作，但你可在 Java 程序<strong>请求</strong> （只是建议它）JVM 运行垃圾收集器，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Runtime rt = Runtime.getRuntime();<br>rt.gc(); <span class="hljs-comment">//请求垃圾收集</span><br></code></pre></td></tr></table></figure><p>另外，<code>finalize()</code> 方法（继承自 <code>Object</code>），能够在对象刚要被<strong>垃圾收集删除之前</strong>运行一些代码</p><blockquote><p>调用 <code>finalize()</code> 实际上能够导致对象免于被删除，比如说，在 <code>finalize()</code> 方法内可以编写代码把一个对象传递给另一个对象，<br>能够有效地阻止该对象符合垃圾收集条件。</p></blockquote><p>但是，任何情况下都<strong>无法强迫</strong>垃圾回收器立即执行回收操作，同样地，任何指定对象的 <code>finalize()</code> 方法<strong>可能运行</strong>，但是<strong>不能指望</strong>它。</p></li><li><p>Java 虚拟机内存模型：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210409001601.png" style="zoom:67%"><blockquote><p><strong>方法区和 Java 堆</strong> 是所有线程共享的数据区，其他均为线程私有的。</p></blockquote></li><li><p>Java 堆：几乎所有的<strong>对象和数组</strong>都是在堆中分配空间的。Java堆分为新生代和老年代连个部分，新生代用于存放刚刚产生的对象和年轻的对象，如果对象一直都没回收，生存得足够长，老年对象就会被移入到老年代。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/image-20210409001841386.png" alt="image-20210409001841386" style="zoom:67%"></li><li><p>静态方法不能够访问非静态数据域，非静态方法能够访问静态数据域</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210607211944.png" style="zoom:67%"></li><li><p>当程序执行下面第三行代码时，由于第一次使用 <code>Student</code> 类，则系统会在第一次使用该类时加载这个类，并初始化这个类，完成初始化后，系统将在<strong>堆内存</strong>为 <code>Student</code> 类分配了一块内存区（其中也包含了类属性 <code>totalStudents</code>，并设置初值） 。接着创建一个 <code>Student</code> <strong>对象</strong>，并将其赋给了 <code>s</code> 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;JoyDee&quot;</span>, <span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210606223538.png" style="zoom:80%"></li><li><p><code>public</code> 修饰符能够使被修饰的成员或顶级类，能够被所有类访问，不论是否处于<strong>同一包</strong>中。</p><p>而 <code>default</code> 通常被称为 <strong>包权限</strong>，即位于同一包中的类之间可互相访问其 <code>default</code> 成员和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WTF</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        Son s = <span class="hljs-keyword">new</span> Son();<br>        System.out.println(s.a);<br>        <span class="hljs-comment">//同一包下，WTF类能够访问Son从Fa继承下来的a变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210607213507.png" style="zoom:67%"> <img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210608213009.png" style="zoom:67%"> <img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210608213213.png" style="zoom:67%"></li><li><p><code>package</code> 语句作为 Java 源文件的<strong>第一条</strong>语句，指明该文件中定义的类所在的包。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JoyDee.weekFourTeen;<br><span class="hljs-comment">//该文件中所在的类位于 ./JoyDee/weekFourTeen 目录下</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>一个 Java 源文件只能包含一个 <code>package</code> 语句，但可包含多个 <code>import</code> 语句</p></blockquote></li><li><p>数据封装的好处——保持类的不变式，即构造方法和修改器都要求保证<strong>每个对象</strong>初始时一定要满足某个合法条件，而且是<strong>整个生命周期</strong>中都满足这个条件。如下对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSides</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s1, <span class="hljs-keyword">double</span> s2, <span class="hljs-keyword">double</span> s3)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s1 &lt; <span class="hljs-number">0</span> || s2 &lt; <span class="hljs-number">0</span> || s3 &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span>((s1 + s2 &gt; s3) &amp;&amp; (s1 + s3 &gt; s2) &amp;&amp; (s2 + s3 &gt; s1))&#123;<br>        <span class="hljs-keyword">this</span>.side1 = s1;<br>        <span class="hljs-keyword">this</span>.side2 = s2;<br>        <span class="hljs-keyword">this</span>.side3 = s3;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，其他好处见PPT（ch9 P141）</p></li><li><p>关于单例类，其特点在于：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210608214639.png" style="zoom:67%"><p>暂时咕咕咕（P152）</p></li></ul><h1 id="Chapter-10-面向对象的思考"><a class="header-anchor" href="#Chapter-10-面向对象的思考">¶</a>Chapter 10. 面向对象的思考</h1><h2 id="类之间的关系"><a class="header-anchor" href="#类之间的关系">¶</a>类之间的关系</h2><ol><li><p><strong>依赖</strong>：A访问B的属性或方法，或者类A负责实例化类B</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615160502.png" style="zoom:67%"></li><li><p><strong>关联</strong>：A能够对B做什么</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615161544.png" style="zoom:67%"><p>牢记下面这张图：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615162452.png" style="zoom:67%"> <img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615162931.png" style="zoom:67%"><blockquote><p>关联关系和聚集关系统称为组合。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615164755.png" style="zoom:67%"></blockquote><ul><li><p><strong>聚集</strong>（has-a）：关联的特殊形式，一个对象可被多个其他聚集对象所拥有</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615163255.png" style="zoom:67%"></li><li><p><strong>组成</strong>（Composition）：聚合的加强形式，一个对象只归属于一个聚集对象。整体与部分的关系，部分不能离开整体而单独存在</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615163808.png" style="zoom:67%"></li></ul></li><li><p>泛化：一种继承关系。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615165631.png" style="zoom:67%"></li><li><p>实现：一种类与接口的关系</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615165822.png" style="zoom:67%"></li></ol><h2 id="包装类"><a class="header-anchor" href="#包装类">¶</a>包装类</h2><ul><li><p><code>char</code> 的包装类为 <code>Character</code>；<code>int</code> 的包装类为 <code>Integer</code></p></li><li><p>包装类没有无参数构造方法，所有的包装类的实例都是<strong>不可变</strong>的。</p><blockquote><p>注意，包装类一定有 <code>String</code> 的有参构造方法，另一有参构造方法的参数是它对应的基本数据类型，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Byte b = <span class="hljs-keyword">new</span> Byte((<span class="hljs-keyword">byte</span>) <span class="hljs-number">123</span>);<br>Byte c = <span class="hljs-keyword">new</span> Byte(<span class="hljs-number">123</span>); <span class="hljs-comment">//错误!!Byte没有Byte(int)的有参构造方法</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">23</span>); <span class="hljs-comment">//Integer(int value)</span><br>Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">&quot;23&quot;</span>)<span class="hljs-comment">//Integer(String s) </span><br>Integer z = Integer.valueOf(<span class="hljs-number">233</span>); <span class="hljs-comment">//static方法：valueOf(int x)</span><br>Integer q = Integer.valueOf(<span class="hljs-string">&quot;233&quot;</span>); <span class="hljs-comment">//static方法，传入String参数</span><br><br><span class="hljs-keyword">int</span> w = y.intValue(); <span class="hljs-comment">//Integer转换为int基本类型</span><br><span class="hljs-keyword">double</span> v = y.doubleValue(); <span class="hljs-comment">//Integer转换为double基本类型</span><br><span class="hljs-keyword">int</span> bit16 = Integer.parseInt(<span class="hljs-string">&quot;-FF&quot;</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">//第二个参数是进制，returns -255</span><br></code></pre></td></tr></table></figure><p>坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = Integer.parseInt(<span class="hljs-string">&quot;23&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">//正确，自动装箱</span><br>Double d = <span class="hljs-keyword">new</span> Double(); <span class="hljs-comment">//错误，没有无参构造方法</span><br><span class="hljs-keyword">double</span> j = (Double.valueOf(<span class="hljs-string">&quot;23.4&quot;</span>)).intValue(); <span class="hljs-comment">//正确，强制类型转换</span><br><span class="hljs-keyword">double</span> f = (Double.valueOf(<span class="hljs-string">&quot;23.4&quot;</span>)).toString(); <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>装箱一般发生在赋值和方法调用中</p><blockquote><p>编译器在生成类的字节码时，插入必要的方法调用，虚拟机只是执行这些字节码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">3</span> + <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>); <span class="hljs-comment">//正确</span><br>Integer y = <span class="hljs-number">3.0</span> <span class="hljs-comment">//错误，double不可能自动装箱为Integer，需要强制转换</span><br><br><span class="hljs-keyword">double</span> z = <span class="hljs-number">3.4</span>;<br>System.out.println(z.intValue()); <span class="hljs-comment">//错误，基本类型不可能调用包装类的方法</span><br><br>Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>);<br>Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);<br>System.out.println(x * y); <span class="hljs-comment">//6</span><br>System.out.println(x.floatValue()); <span class="hljs-comment">//2.0</span><br></code></pre></td></tr></table></figure></li><li><p>包装类型的比较一定要使用 <code>equals</code> ，使用 <code>==</code> 比较两个包装对象，取决于是否值在 -128 到 127</p><blockquote><p>由源码的说明，如果 <code>int</code> 型参数 <code>i</code> 在 <code>IntegerCache.low</code> 和 <code>IntegerCache.high</code> 范围内，则直接由 <code>IntegerCache</code> 返回（即直接从缓存中取出）；否则 <code>new</code> 一个新的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">9999</span>;<br>Integer b = <span class="hljs-number">9999</span>;<br>System.out.println(a.equals(b)); <span class="hljs-comment">//true</span><br>System.out.println(a == <span class="hljs-number">9999</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="String"><a class="header-anchor" href="#String">¶</a>String</h2><ul><li><p>由于 <code>String</code> 是引用对象类型，故其对象存储的并非是字符串的值，而是它的对象引用</p></li><li><p>注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String x = <span class="hljs-string">&quot;Java&quot;</span>;<br>x.concat(<span class="hljs-string">&quot;2333&quot;</span>);<span class="hljs-comment">//ignored</span><br>x = x.concat(<span class="hljs-string">&quot;Rules!&quot;</span>);<br>x.toLowerCase(); <span class="hljs-comment">//ignored</span><br>System.out.println(x); <span class="hljs-comment">//JavaRules!</span><br></code></pre></td></tr></table></figure></li><li><p>当编译器遇到 <code>String</code> 常量时，会先检查该池内是否已存在相同的，若有就将新的引用<strong>指向现有</strong>的 <code>String</code> ，它们会在内存中共享同一块地址。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210616195226.png" style="zoom:67%"></li><li><p>注意常量池坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;Java&quot;</span>;<br>String s1 = <span class="hljs-string">&quot;Java&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;Ja&quot;</span> + <span class="hljs-string">&quot;va&quot;</span>;<br>System.out.println(s == s1); <span class="hljs-comment">//true</span><br>System.out.println(s == s2); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><blockquote><p><code>&quot;Ja&quot;</code> 和 <code>&quot;va&quot;</code> 都是字符串常量，当一个字符串由多个字符串常量连接而成时，它本身也是字符串常量</p></blockquote></li><li><p>检查一个字符串既不是 <code>null</code> ，也不是空串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str.length() != <span class="hljs-number">0</span> &amp;&amp; str != <span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure></li><li><p>字符串转换为数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] chars = <span class="hljs-string">&quot;Java&quot;</span>.toCharArray();<br></code></pre></td></tr></table></figure><p>数组转换为字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;);<br>String str2 = String.valueOf(<span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><code>String</code> 类提供几个 <code>valueOf</code> 静态方法，可将 <code>char</code> 、<code>char[]</code> 、<code>double</code>、<code>long</code>、<code>int</code> 和 <code>float</code> 等数值转换为字符串</p></li><li><p>注意 <code>equals</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">boolean</span> ans = s1.equals(s2); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li><li><p><code>StringBuilder</code> 或 <code>StringBuffer</code> 都能存储指定容量的字符串（若超出，则自动扩大）</p><blockquote><p>单任务访问：<code>StringBuilder</code>，多任务并发访问：<code>StringBuffer</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder s0 = <span class="hljs-string">&quot;0123&quot;</span>; <span class="hljs-comment">//错误！！！！</span><br>System.out.println(s1.substring(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">//区间为[0,2)</span><br>StringBuilder s1  = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;0123456789&quot;</span>);<br>s1.insert(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;zzzz&quot;</span>); <span class="hljs-comment">//第一个参数为偏移长度，故012zzzz3456789</span><br>s1.delete(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//区间为[0,2)</span><br></code></pre></td></tr></table></figure><blockquote><p><code>trimTosize()</code> 能够将 <code>StringBuilder</code> 对象的容量降到实际大小</p></blockquote></li><li><p>关于<code>subString()</code>：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210621214429.png" style="zoom:80%"></li><li><p>关于 <code>compareTo()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;Wec&quot;</span>;<br>String s2 = <span class="hljs-string">&quot;Pro&quot;</span>;<br>System.out.println(s1.compareTo(s2)); <span class="hljs-comment">//7</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="Chapter-11-继承和多态"><a class="header-anchor" href="#Chapter-11-继承和多态">¶</a>Chapter 11. 继承和多态</h1><p>OOP语言的三个典型特征：封装、继承、<strong>多态</strong></p><h2 id="super-调用父类的构造方法"><a class="header-anchor" href="#super-调用父类的构造方法">¶</a>super 调用父类的构造方法</h2><ul><li><p>注意：<strong>父类的构造方法不能够被子类继承</strong>，若要调用父类构造方法，必须使用关键字 <code>super</code> ，且必须放在构造方法的<strong>第一行</strong>。</p></li><li><p>若子类没有显式地使用 <code>super</code> ，则父类<strong>无参</strong>构造方法将被自动地执行。</p><blockquote><p>Java程序在创建某个类的对象时，会隐式地创建该类的<strong>父类</strong>对象，只要有一个子类对象存在，则一定存在一个与之对应的父类对象。</p></blockquote><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210609165606.png" style="zoom:80%"></li></ul><h2 id="构造方法链"><a class="header-anchor" href="#构造方法链">¶</a>构造方法链</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Son s = <span class="hljs-keyword">new</span> Son();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pa</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pa</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a grandpa&quot;</span>); <span class="hljs-comment">//先执行</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pa</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fa</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a father&quot;</span>); <span class="hljs-comment">//再执行</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a son&quot;</span>); <span class="hljs-comment">//最后执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a father&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Son</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I am a son&quot;</span>);<br>    &#125; <span class="hljs-comment">//此时编译错误，由于子类构造方法隐式调用了父类的无参构造方法，而Fa不存在无参构造方法（声明了有参构造方法就不会自动生成了），</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>若一个类要拓展，应提供一个无参构造方法以避免编程错误。</p></blockquote><h2 id="重写父类的方法"><a class="header-anchor" href="#重写父类的方法">¶</a>重写父类的方法</h2><blockquote><p>注意，重写都是针对<strong>实例方法</strong>，不能是类方法。因此若父类和子类都定义相同的静态方法，父类方法将会被隐藏</p></blockquote><p>“两同两小一大”规则：</p><ul><li>两同：方法名相同，形参列表相同</li><li>两小——返回值更加地具体：子类方法返回值类型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">⊆</span></span></span></span> 父类；子类方法声明抛出的异常类型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">⊆</span></span></span></span> 父类</li><li>一大——访问权限：子类方法的访问权限<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊇</mo></mrow><annotation encoding="application/x-tex">\supseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">⊇</span></span></span></span> 父类</li></ul><p>注意要点：</p><ul><li>子类对象无法访问父类被重写的方法，但可在子类方法体中调用</li><li>当父类方法具有 <code>private</code> 访问权限，则该方法对其子类是隐藏的，既不能访问，更不能重写</li><li>父类的构造方法不允许调用可被子类覆盖的方法，否则有可能抛出空指针异常</li></ul><h2 id="多态及动态绑定"><a class="header-anchor" href="#多态及动态绑定">¶</a>多态及动态绑定</h2><p><strong>多态</strong>：若编译时类型和运行时类型不一致，则出现所谓的多态。</p><blockquote><p>多态是指当系统A访问B的服务时，系统B可通过多种实现方式来提供服务，而这一切对系统A是透明的。</p></blockquote><p>其存在的条件如下：</p><ul><li><p>存在于继承中</p></li><li><p>必须有方法的覆盖</p><blockquote><p>对象的<strong>属性不具有多态性</strong>，因此访问数据域或静态方法时，引用变量所声明的类型在编译时就已经决定了使用哪个数据域或静态方法了。</p></blockquote></li></ul><p><strong>动态绑定</strong>的例子：若 <code>GraduateStudent</code> 中没有定义 <code>toString</code> 方法，JVM会向上搜索，找到父类 <code>Student</code>，结果发现了 <code>toString</code> 方法，就会调用该方法。</p><p>牢记下面的程序运行结果！</p><blockquote><p>引用变量在<strong>编译</strong>阶段只能调用其<strong>编译</strong>时类型所具有的方法，但<strong>运行</strong>时则执行它所<strong>运行</strong>时的类型所具有的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Son son = <span class="hljs-keyword">new</span> Son();<br>        System.out.println(<span class="hljs-string">&quot;年龄为&quot;</span> + son.age); <span class="hljs-comment">//20</span><br>        son.baseMethod();  <span class="hljs-comment">//执行从父类继承的run方法</span><br>        son.run(); <span class="hljs-comment">//执行当前类的run方法</span><br>        son.sonMethod(); <span class="hljs-comment">//执行当前类的sonMethod方法</span><br>        <br>        Fa tmp = <span class="hljs-keyword">new</span> Son(); <span class="hljs-comment">//发生多态，编译类型为Son，运行类型为Son</span><br>        System.out.println(<span class="hljs-string">&quot;年龄为&quot;</span> + tmp.age); <span class="hljs-comment">//50，小心坑点！！因为多态只发生在方法上!</span><br>        tmp.baseMethod(); <span class="hljs-comment">//父类的普通方法</span><br>        tmp.run(); <span class="hljs-comment">//注意！！！子类将父类的run方法覆盖了</span><br>        <span class="hljs-comment">//tmp.sonMethod(); 无法调用，必须通过强制类型转换成运行时类型，如下所示</span><br>        ((Son) tmp).sonMethod(); <span class="hljs-comment">//向下转型</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">50</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">baseMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类的普通方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类的run方法&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fa</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类将父类的run方法覆盖了&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sonMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类才拥有的方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用类型的强制转换"><a class="header-anchor" href="#引用类型的强制转换">¶</a>引用类型的强制转换</h2><ul><li><p><strong>父类-&gt;子类</strong>：引用类型间的转换中，父类 -&gt; 子类，且需要<strong>强制</strong>类型转换。其<strong>前提</strong>是，该引用类型实际必须是子类的实例才可以（也就说，编译类型为父类，运行类型为子类），否则会发生<code>ClassCastException</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Fa peo = <span class="hljs-keyword">new</span> Nephew();<br><span class="hljs-comment">//Son son = (Son)peo; 抛出异常</span><br>Nephew nephew = (Nephew)peo;<br></code></pre></td></tr></table></figure></li><li><p><strong>子类-&gt;父类</strong>：当将一个子类对象赋给父类引用变量时，被称为向上转型，自动地完成</p></li></ul><p>注意以下坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">((Fa)<span class="hljs-keyword">new</span> Son()).run(); <span class="hljs-comment">//子类将父类的run方法覆盖了，执行运行类型的方法</span><br></code></pre></td></tr></table></figure><h2 id="instanceof-运算符"><a class="header-anchor" href="#instanceof-运算符">¶</a>instanceof 运算符</h2><ul><li><p>格式：<code>引用类型的变量 instanceof 类名</code></p></li><li><p>在进行强制类型转换之前，可通过 <code>instanceof</code> 运算符判断源对象是否为目标的实例，从而避免出现上述异常</p></li><li><p>它用于判断该对象实际运行的类型（父类或祖先类，也满足条件），而不是看编译时的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Animal animal = <span class="hljs-keyword">new</span> Animal();<br>Cat c = <span class="hljs-keyword">new</span> Cat();<br>System.out.println(animal <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">//true</span><br>System.out.println(animal <span class="hljs-keyword">instanceof</span> Dog); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="final修饰符"><a class="header-anchor" href="#final修饰符">¶</a>final修饰符</h2><p>（一）<strong>修饰两类变量</strong>：两类被 <code>final</code> 修饰的变量，必须<strong>被初始化</strong>，遵循着不可多次赋值或修改的原则</p><blockquote><p>注意，静态的 <code>final</code> 即 <code>static final</code>，（因为 <code>final</code> 必须要有初始化），要么在定义时初始化，要么就在静态初始化块赋值(因为 <code>static</code>)，此时就不能够在构造方法中赋值了!</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ben</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x; <span class="hljs-comment">//基本类型常量，除非是通过构造方法(且只能赋值一次)，其他方法不能修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Ben</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//合法</span><br>        x = <span class="hljs-number">1</span>; <span class="hljs-comment">//编译出错！final修饰的常量只能被赋值一次!</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Ben</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> idx = <span class="hljs-number">233</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Test cur = <span class="hljs-keyword">new</span> Test(); <span class="hljs-comment">//引用类型的常量</span><br>        cur.idx = <span class="hljs-number">666</span>; <span class="hljs-comment">//合法，允许修改引用变量所引用的Test对象的idx属性</span><br>        cur = <span class="hljs-keyword">new</span> Test(); <span class="hljs-comment">//编译出错，不能改变引用变量cur引用的对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（二）<strong>修饰方法</strong>：对父类的某个方法声明为 <code>final</code> 类型时，子类不能够覆盖该方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Class <span class="hljs-title">getClass</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>    <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（三）<strong>修饰类</strong>：用<code>final</code> 修饰的类，不能够有子类，即不能被继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h2 id="ArrayList"><a class="header-anchor" href="#ArrayList">¶</a>ArrayList</h2><p>若将子类放入到定义为父类泛型的 <code>ArrayList</code> 中，将会丢失子类本身的数据类型。若要调用子类的方法，需要进行强制类型转换。</p><p>数组与 <code>ArrayList</code> 的异同：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210609200133.png" style="zoom:80%"><h1 id="Chapter-12-异常"><a class="header-anchor" href="#Chapter-12-异常">¶</a>Chapter 12. 异常</h1><h2 id="异常分类图"><a class="header-anchor" href="#异常分类图">¶</a>异常分类图</h2><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615142708.png" style="zoom:80%"><ul><li><p><code>Error</code> 类以及子类表示程序本身无法修复，编译器不会检查他们，其错误一般由Java虚拟机抛出，此时程序就会被终止。</p><blockquote><p>一般不会通过继承 <code>Error</code> 类来创建用户自定义的错误类</p></blockquote></li><li><p><code>RuntimeException</code> <strong>运行时异常（免检异常）</strong>：当出现这类异常，<strong>即便没有捕获或者抛出，也会编译通过</strong>。一旦出错，则建议终止程序，如：</p><blockquote><p>通常是执行了错误操作，需要改进程序设计</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>System.out.println(arr[<span class="hljs-number">4</span>]);<br><span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException ...</span><br></code></pre></td></tr></table></figure><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615145822.png" style="zoom:67%"></li><li><p>其他 <code>Exception</code> 类以及子类均属于<strong>编译时异常（受检异常）</strong>，即Java编译器会检查它，当程序中可能出现这类异常时，要么用 <code>try-catch</code> 语句捕获，要么用 <code>throws</code> 子句声明抛出，否则编译不会通过</p><blockquote><p>通常是能够被修复的，不会导致整个程序的终止</p></blockquote></li></ul><h2 id="异常跟踪栈"><a class="header-anchor" href="#异常跟踪栈">¶</a>异常跟踪栈</h2><p>异常跟踪栈与“方法调用栈”方向相反，异常先从<strong>发生异常的方法</strong>逐渐向外传播，首先传给该方法的调用者，然后再向上传…直至最后传给 <code>main</code> 方法。</p><blockquote><p>若 <code>main</code> 依然没有处理异常，则JVM会中止该程序，并打印异常的跟踪栈。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SelfException</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SelfException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SelfException</span>&#123;<br>        firstMethod();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">firstMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SelfException</span>&#123;<br>        secondMethod();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">secondMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SelfException</span>&#123;<br>        thirdMethod();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">thirdMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SelfException</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SelfException(<span class="hljs-string">&quot;我是异常，来自thirdMethod&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果显示如下：</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615114405.png" style="zoom:80%"><h2 id="异常处理方式"><a class="header-anchor" href="#异常处理方式">¶</a>异常处理方式</h2><p>①声明一个异常；②抛出一个异常；③捕获一个异常</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615144548.png" style="zoom:67%"><ul><li><p><code>throws</code> 声明<strong>可能</strong>会出现的异常，若 <code>main</code> 方法不知道如何处理，则可以使用 <code>throws</code> 声明抛出给 JVM 进行处理——打印异常跟踪栈，终止程序运行。</p></li><li><p>若 <code>try</code> 块被执行一次，则 <code>try</code> 块后只有一个 <code>catch</code> 块会被执行（除非使用循环）</p></li><li><p>若存在 <code>try</code> 块时，<strong>总会</strong>执行 <code>finally</code> 块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;1111&quot;</span>); <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;2222&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;3333&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//1111</span><br><span class="hljs-comment">//2222</span><br><span class="hljs-comment">//3333</span><br></code></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<code>finally</code> 语句不被执行的唯一情况是先执行了用于终止程序（终止当前Java虚拟机进程）的 <code>System.exit()</code> 方法。</p><p>即便在 <code>try</code> 或 <code>catch</code> 代码块中的 <code>return</code> 语句时，只要有 <code>finally</code> 代码块，都会执行。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615151514.png" style="zoom:67%"><p>再注意，<code>finally</code> 代码块不能通过重新给变量赋值的方式来改变 <code>return</code> 语句的<strong>返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(woc()); <span class="hljs-comment">//i = 1</span><br>        System.out.println(x); <span class="hljs-comment">//x = 3</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">woc</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException();<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            ++i;<br>            x++;<br>            System.out.println(<span class="hljs-string">&quot;In the final block: &quot;</span> + i); <span class="hljs-comment">//i = 2</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210615152507.png"></li></ul><h1 id="Chapter-13-抽象类和接口"><a class="header-anchor" href="#Chapter-13-抽象类和接口">¶</a>Chapter 13. 抽象类和接口</h1><h2 id="抽象类定义"><a class="header-anchor" href="#抽象类定义">¶</a>抽象类定义</h2><p>有抽象方法的类<strong>只能</strong>定义为抽象类，抽象类可以没有抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 返回类型 方法名 (参数列表);<span class="hljs-comment">//抽象方法不能有方法体</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类可以包含<strong>属性</strong>、方法（普通方法和抽象方法均可）、<strong>构造方法</strong>（只能是普通方法，不能被 <code>abstract</code> 修饰）。</p><blockquote><p>抽象类的构造方法不能用于创建实例，主要用于被子类调用</p></blockquote><p>以下三种情况，<strong>只能定义</strong>为抽象类：</p><ul><li>类中定义了一个抽象方法</li><li>继承了抽象父类，但没实现父类包含的<strong>所有</strong>抽象方法</li><li>实现了接口，但没实现接口包含的<strong>所有</strong>抽象方法</li></ul><h2 id="abstract关键字"><a class="header-anchor" href="#abstract关键字">¶</a>abstract关键字</h2><p><code>abstract</code> 不能用于修饰<strong>构造</strong>方法。</p><p>此外：</p><ul><li>对于类或者方法的修饰， <code>final</code> 与 <code>abstract</code> 不能够同时使用</li><li>对于方法， <code>static</code> 与 <code>abstract</code> 不能够同时使用</li><li>对于方法，<code>private</code> 与 <code>abstract</code> 不能够同时使用</li></ul><h2 id="接口定义"><a class="header-anchor" href="#接口定义">¶</a>接口定义</h2><p>相比于抽象类，接口更加特殊，不能够包含普通方法，其<strong>所有方法</strong>都是抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] <span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名 </span>&#123;<br>    <span class="hljs-number">0</span>到n个常量定义...<br>    <span class="hljs-number">0</span>到多个抽象方法定义...<br>    <span class="hljs-number">0</span>到多个内部类、接口、枚举定义...<br>    <span class="hljs-number">0</span>到多个私有方法、默认方法（实例方法）或类方法定义....(JDK <span class="hljs-number">1.8</span> 之后)<br>&#125;<br></code></pre></td></tr></table></figure><p>接口的声明的<strong>属性</strong>默认（不论是否显式声明）为 <code>public static final</code> ，同时，接口中定义的方法默认 <code>public abstract</code> （即抽象方法），举例如下：</p><blockquote><p>接口中<strong>无构造方法和初始化</strong>，故接口里定义的属性只能在定义时指定默认值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>; <span class="hljs-comment">//相当于 public static final int id = 1</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//相当于 public abstract void start()</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//相当于 public abstract void run()</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//相当于 public abstract void stop()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有小坑点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//根据”两小一大“，方法m的访问权限(大)必须是public</span><br>        System.out.println(<span class="hljs-string">&quot;2333&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，一个类不能继承多个类，但一个接口可能继承多个接口。</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210609211728.png" style="zoom:67%"><h2 id="Comparable接口"><a class="header-anchor" href="#Comparable接口">¶</a>Comparable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 <code>Comparable</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-title">implement</span> <span class="hljs-title">Comparable</span>&lt;类名&gt;</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CompareTo</span><span class="hljs-params">(T other)</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Cloneable-接口"><a class="header-anchor" href="#Cloneable-接口">¶</a>Cloneable 接口</h2><p><code>Cloneable</code> 接口是空的，称为标记接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>类只有当<strong>实现了 <code>Cloneable</code> 接口</strong>（即标记为可复制的），其对象内部才能够<strong>使用 <code>Object</code> 类</strong>中定义的 <code>clone</code> 方法实现克隆功能。</p><blockquote><p>若没有实现该接口，就调用 <code>Object</code> 的 <code>clone()</code> 会抛出异常</p></blockquote><p>该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>;<br></code></pre></td></tr></table></figure><blockquote><p>由于是 <code>protected</code> ，只能在实现该接口的对象的方法内部调用，并且需要对该方法进行覆盖。如下调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> idx = <span class="hljs-number">233</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Fa c = <span class="hljs-keyword">new</span> Fa();<br>        System.out.println(c.hashCode()); <span class="hljs-comment">//989110044</span><br>        System.out.println(c.date.hashCode()); <span class="hljs-comment">//-194351978</span><br>        Fa a = (Fa)c.clone();<br>        System.out.println(a.hashCode()); <span class="hljs-comment">//424058530</span><br>        System.out.println(a.date.hashCode()); <span class="hljs-comment">//-194351978</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fa</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">public</span> Date date = <span class="hljs-keyword">new</span> Date();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个过程中的浅拷贝与深拷贝</p><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210610134314.png" style="zoom:67%"><h2 id="接口与抽象类的相同点"><a class="header-anchor" href="#接口与抽象类的相同点">¶</a>接口与抽象类的相同点</h2><img src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/20210610134451.png" style="zoom:50%"><h2 id="接口与抽象类的不同点"><a class="header-anchor" href="#接口与抽象类的不同点">¶</a>接口与抽象类的不同点</h2><table><thead><tr><th></th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td>成员数据</td><td>必须常量</td><td>既可常量，也可变量</td></tr><tr><td>成员方法</td><td>不能有方法体的普通方法</td><td>完全可以包含普通方法</td></tr><tr><td>构造方法</td><td>不能够包含</td><td>可以包含，但不能被 <code>abstract</code> 修饰，且不能用来创建实例</td></tr><tr><td>共同的根</td><td>无</td><td><code>Object</code></td></tr><tr><td>初始化块</td><td>不能</td><td>可以</td></tr><tr><td>实现与继承</td><td>一个类可直接实现多个接口，一个接口可继承多个接口</td><td>一个类最多只有一个直接父类</td></tr></tbody></table><h2 id="李氏替换原则"><a class="header-anchor" href="#李氏替换原则">¶</a>李氏替换原则</h2><p>主要用于判断两个类之间是否符合继承关系。父类出现的地方，子类可以将其替换，且程序的行为不会发生改变。</p><p>可以理解为，若一个类继承了另一个类，两者的行为应该是一致的。子类不能添加任何父类没有的<strong>附加约束</strong>（比如正方形在设置长度或宽度时要受到长宽相等的约束）。</p><p>若违背该原则，应该将两个类共有属性及方法提炼出来作为抽象父类，各自继承父类并重写属于自己的方法</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Joy Dee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.joydee.top/posts/83a0adbc/">https://www.joydee.top/posts/83a0adbc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.joydee.top" target="_blank">JoyDee's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 不妨打赏一下？</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.joydee.cloud/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/da2a8f19/"><img class="prev-cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/shujukuxitonggailun.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「数据库系统概论」问答题总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/c6047a43/"><img class="next-cover" src="/img/my-loading.jpg" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数电简要总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/a0f59037/" title="「JavaSE学习笔记04」异常"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-31</div><div class="title">「JavaSE学习笔记04」异常</div></div></a></div><div><a href="/posts/4775c8be/" title="「JavaSE学习笔记03」继承、接口、多态、内部类"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-25</div><div class="title">「JavaSE学习笔记03」继承、接口、多态、内部类</div></div></a></div><div><a href="/posts/feb278c3/" title="「JavaSE学习笔记05」泛型、集合"><img class="cover" src="/img/my-loading.jpg" data-lazy-src="https://gitee.com/j__strawhat/MyImages/raw/master/rc24-java-25yrs.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-04</div><div class="title">「JavaSE学习笔记05」泛型、集合</div></div></a></div></div></div><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud/avatar.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">Joy Dee</div><div class="author-info__description">Cause I have a dream.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">129</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/J-StrawHat"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/J-StrawHat" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:422148166@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/j_strawhat-2/" target="_blank" title="LeetCode"><i class="fas fa-code"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-box-open"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">Chapter 1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-text">Java跨平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8CJava%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">编译与运行Java源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95"><span class="toc-text">main方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">Java源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%94%99%E8%AF%AF"><span class="toc-text">编程错误</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2"><span class="toc-text">Chapter 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">Java标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner"><span class="toc-text">Scanner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E4%B8%8E%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">字符型与数值型数据的转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-5-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">Chapter 3+5 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-text">switch 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#random-%E6%96%B9%E6%B3%95"><span class="toc-text">random 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-%E6%96%B9%E6%B3%95"><span class="toc-text">Chapter 6. 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="toc-text">方法签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">static修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BD%93"><span class="toc-text">方法体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">方法中参数传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-7-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">Chapter 7. 一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">数组的长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">数组的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">可变长参数列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Arrays 工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">命令行参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter9-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-text">Chapter9. 对象和类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">Chapter 10. 面向对象的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-11-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">Chapter 11. 继承和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#super-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">super 调用父类的构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%93%BE"><span class="toc-text">构造方法链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">重写父类的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%8A%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">多态及动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">引用类型的强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">instanceof 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">final修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-12-%E5%BC%82%E5%B8%B8"><span class="toc-text">Chapter 12. 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB%E5%9B%BE"><span class="toc-text">异常分类图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%B7%9F%E8%B8%AA%E6%A0%88"><span class="toc-text">异常跟踪栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">异常处理方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-13-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">Chapter 13. 抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-text">抽象类定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">abstract关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparable%E6%8E%A5%E5%8F%A3"><span class="toc-text">Comparable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cloneable-%E6%8E%A5%E5%8F%A3"><span class="toc-text">Cloneable 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">接口与抽象类的相同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-text">接口与抽象类的不同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%8E%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-text">李氏替换原则</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-car"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c6767314/" title="卷积神经网络"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="卷积神经网络"></a><div class="content"><a class="title" href="/posts/c6767314/" title="卷积神经网络">卷积神经网络</a><time datetime="2021-09-14T10:42:40.000Z" title="发表于 2021-09-14 18:42:40">2021-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a8ca9651/" title="模型选择方法、欠拟合和过拟合、正则化技术"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="模型选择方法、欠拟合和过拟合、正则化技术"></a><div class="content"><a class="title" href="/posts/a8ca9651/" title="模型选择方法、欠拟合和过拟合、正则化技术">模型选择方法、欠拟合和过拟合、正则化技术</a><time datetime="2021-09-10T23:29:40.000Z" title="发表于 2021-09-11 07:29:40">2021-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c3f7cdb7/" title="多层感知机"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="多层感知机"></a><div class="content"><a class="title" href="/posts/c3f7cdb7/" title="多层感知机">多层感知机</a><time datetime="2021-09-10T05:59:40.000Z" title="发表于 2021-09-10 13:59:40">2021-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1e40c7d5/" title="Softmax回归模型解决多分类问题"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Softmax回归模型解决多分类问题"></a><div class="content"><a class="title" href="/posts/1e40c7d5/" title="Softmax回归模型解决多分类问题">Softmax回归模型解决多分类问题</a><time datetime="2021-08-11T02:53:40.000Z" title="发表于 2021-08-11 10:53:40">2021-08-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a7ee0bf0/" title="Logistic回归模型解决二分类问题"><img src="/img/my-loading.jpg" data-lazy-src="https://cdn.joydee.cloud//pytorch.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Logistic回归模型解决二分类问题"></a><div class="content"><a class="title" href="/posts/a7ee0bf0/" title="Logistic回归模型解决二分类问题">Logistic回归模型解决二分类问题</a><time datetime="2021-08-09T02:47:41.000Z" title="发表于 2021-08-09 10:47:41">2021-08-09</time></div></div></div></div></div></div></main><footer id="footer" style="background:#393d49"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Joy Dee</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hope you learn something in my blog and leave your comment!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论区"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章中的关键词" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/copy-tex.min.css"><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.joydee.top/",region:"",katex:{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1}},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo.joydee.top/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},i=(i=!1)=>{"object"==typeof twikoo?(o(),i&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),i&&t&&setTimeout(e,0)})};i(!0)})()</script></div><script>window.addEventListener("load",()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}'>${e[n].content}</a>\n        <div class='name'><span>${e[n].nick} / </span><time datetime="${e[n].date}">${btf.diffDate(e[n].date,!0)}</time></div>\n        </div></div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n.innerHTML=t,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.joydee.top/",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map(e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t});saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),15/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").innerHTML="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)})</script><script src="https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax",".tk-comments-container"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!0,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","UA-184747878-1",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script></div></body></html>